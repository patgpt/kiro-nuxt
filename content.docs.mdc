# Define Content Collections

> Learn how to define and configure content collections in your Nuxt application.

The Nuxt Content module automatically parses any content files within the `content/` directory located at the root of your Nuxt application. This setup allows you to freely structure the folder to suit your project's needs.

For better organization, consider using Content Collections, which let you categorize and manage content more effectively. These collections are defined in a `content.config.ts` file.

<warning>

If no `content.config.ts` file is present, all files within the content folder are parsed and imported by default. However, once a config file is added, only files matching the specified path patterns defined in collections will be imported.

</warning>

## What are Content Collections?

Content Collections organize related items within your Nuxt Content project. They provide a structured way to manage your content, making it easier to query, display, and maintain your site's data.

Key features include:

- **Logical Grouping**: Group similar content together, such as blog posts, product pages, or documentation articles
- **Shared Configuration**: Apply common settings and validations across all items within a collection
- **Improved Querying**: Fetch and filter related content items efficiently
- **Automatic Type Inference**: Get type safety and autocompletion in your development environment
- **Flexible Structure**: Organize collections by content type, category, or any other logical grouping that suits your needs

## Defining Collections

Create a `content.config.ts` file in your project's root directory. This special file configures your collections database, utility types, and content handling.

Here's a basic example:

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      // Load every file inside the `content` directory
      source: '**',
      // Specify the type of content in this collection
      type: 'page'
    })
  }
})
```

<warning>

Currently, a document is designed to be present in only one collection at a time. If a file is referenced in multiple collections, live reload will not work correctly. To avoid this, it is recommended to use the `exclude` attribute to explicitly exclude a document from other collections using appropriate regex patterns.

This topic is still under discussion in this issue: [nuxt/content#2966](https://github.com/nuxt/content/issues/2966).

</warning>

### Collection Schema

Schemas enforce data consistency within a collection and serve as the source of truth for TypeScript types.

On top of the built-in fields, you can define a schema by adding the `schema` property to your collection by using a [`zod`](https://zod.dev) schema:

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      source: 'blog/*.md',
      type: 'page',
      // Define custom schema for docs collection
      schema: z.object({
        tags: z.array(z.string()),
        image: z.string(),
        date: z.date()
      })
    })
  }
})
```

<note>

`@nuxt/content` exposes a `z` object that contains a set of Zod schemas for common data types. Check [Zod’s README](https://github.com/colinhacks/zod) for complete documentation on how Zod works and what features are available.

</note>

<tip>

You can define as many collections as you want to organize different types of content.

</tip>

## Querying Collections

Use the [`queryCollection`](/docs/utils/query-collection) util to fetch one or all items from a collection:

```vue [pages/blog.vue]
<script setup lang="ts">
const { data: posts } = await useAsyncData('blog', () => queryCollection('blog').all())
</script>

<template>
  <div>
    <h1>Blog</h1>
    <ul>
      <li v-for="post in posts" :key="post.id">
        <NuxtLink :to="post.path">{{ post.title }}</NuxtLink>
      </li>
    </ul>
  </div>
</template>
```

<note to="/docs/utils/query-collection">

Learn more about the available query options in our `queryCollections` API documentation.

</note>

## defineCollection()

The `defineCollection` function defines a collection in your content configuration. Here's its TypeScript signature:

```ts
function defineCollection(collection: Collection): DefinedCollection

type Collection = {
  // Determines how content is processed
  type: 'page' | 'data'
  // Specifies content location
  source?: string | CollectionSource
  // Zod schema for content validation and typing
  schema?: ZodObject<T>
}
```

<note to="/docs/collections/types">

Learn more about collection types.

</note>

```ts
type CollectionSource = {
  // Glob pattern for content matching
  include: string
  // .path prefix (only applies to 'page' type)
  prefix?: string
  // Glob patterns to exclude content
  exclude?: string[]
  // Root directory for content matching
  cwd?: string
  // Remote git repository URL (e.g., https://github.com/nuxt/content)
  repository?: string
  // Authentication token for private repositories (e.g., GitHub personal access token)
  authToken?: string
}
```

<note to="/docs/collections/sources">

Learn more about collection sources.

</note>

The function returns the defined collection object.


# Collection Types

> Learn about the two types of collections you can define in Nuxt Content.

In Nuxt Content, you can specify a type for each collection, depending on the intended purpose of the collection files. Collections can be defined as either **page** or **data** types.

For both types, built-in fields are generated. Every collection includes these default fields:

- `id`: Unique content identifier
- `stem`: File path without extension (used for sorting and location)
- `extension`: File extension
- `meta`: Custom fields not defined in the collection schema

## Page type

```ts
defineCollection({
  source: '**/*.md',
  type: 'page'
})
```

<tip>

Use the **page** type if there is a 1-to-1 relationship between content files and pages on your site.

</tip>

### Path generation

Nuxt Content will automatically generate a path for each file in the collection, making it easy to create URL mappings.

Here are examples of generated paths based on file structure:

<table>
<thead>
  <tr>
    <th>
      
    </th>
    
    <th>
      
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      
    </td>
    
    <td>
      
    </td>
  </tr>
  
  <tr>
    <td>
      File
    </td>
    
    <td>
      Path
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        content/index.md
      </code>
    </td>
    
    <td>
      <code>
        /
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        content/about.md
      </code>
    </td>
    
    <td>
      <code>
        /about
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        content/blog/index.md
      </code>
    </td>
    
    <td>
      <code>
        /blog
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        content/blog/hello.md
      </code>
    </td>
    
    <td>
      <code>
        /blog/hello
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        content/1.guide/2.installation
      </code>
    </td>
    
    <td>
      <code>
        /guide/installation
      </code>
    </td>
  </tr>
</tbody>
</table>

<note>

You can use the helper [`queryCollection('COLLECTION').path('PATH')`](/docs/utils/query-collection) to retrieve content by a specific path.

</note>

### Schema Overrides

When you use the **page** type, Nuxt Content generates several standard fields that are commonly used for web pages. These fields provide structure and are **automatically** applied to the collection’s schema:

- `path`: Generated route path
- `title`: Page title
- `description`: Page description
- `seo`: SEO metadata (to be used with Nuxt's `useSeoMeta` composable)
- `body`: Page content parsed as AST
- `navigation`: Page navigation configuration (for [queryCollectionNavigation](/docs/utils/query-collection-navigation))

Here is the corresponding schema applied:

```ts
path: z.string(),
  title: z.string(),
  description: z.string(),
  seo: z.intersection(
    z.object({
      title: z.string().optional(),
      description: z.string().optional(),
      meta: z.array(z.record(z.string(), z.any())).optional(),
      link: z.array(z.record(z.string(), z.any())).optional(),
    }),
    z.record(z.string(), z.any()),
  ).optional().default({}),
  body: z.object({
    type: z.string(),
    children: z.any(),
    toc: z.any(),
  }),
  navigation: z.union([
    z.boolean(),
    z.object({
      title: z.string(),
      description: z.string(),
      icon: z.string(),
    }),
  ]).default(true),
```

<note>

You can override any of these fields by defining them in the collection’s schema.

</note>

## Data type

```ts
defineCollection({
  source: 'authors/**.yml',
  type: 'data'
})
```

The data type is useful for content that doesn't directly correspond to a webpage but instead represents structured data you might want to query and display within your application.

With data collections, you have complete control over the schema, allowing you to define custom structures.

<note>

There's no strict relationship between collection type and file extension. For instance, a **page** collection can use [Markdown](/docs/files/markdown) or [YAML](/docs/files/yaml) or [JSON](/docs/files/json) files, and **data** collections can use any of these formats as well.

</note>

## Ordering Files

For both types, you may want to control the display order in lists. Use numeric prefixes in file and directory names to specify an order. Nuxt Content will use these numbers when ordering content lists.

<note>

Nuxt Content uses alphabetical order for sorting, so if you want to use numerical order, you need to prefix single digit numbers with `0`. For example, without the `0` prefix, `10.foo.md` would come before `2.bar.md`.

</note>

```text [Directory structure]
content/
  1.frameworks/
    1.vue.md
    2.nuxt.md
    ...
  2.examples/
    01.nuxthub.md
    02.vercel.md
    03.netlify.md
    04.heroku.md
    ...
    10.cloudflare.md
    index.md
```

<warning>

Separate number from file name using `.` character. Using any other separator will not work.

</warning>


# Collection Sources

> Learn how to import your files in Nuxt Content collections.

Nuxt Content provides several ways to import content files into your collection. You can configure the source by using the `source` property within `defineCollection`:

```ts [content.config.ts]
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      source: '**',
      type: 'page'
    })
  }
})
```

## `source`

The `source` property can be defined as either a string (following a glob pattern) or an object, allowing more detailed source configuration for your target directory and files within the content folder.

**Example:**

- `source: '**'` includes all files within the content directory and its subdirectories.
- `source: '**/*.md'`includes all `Markdown` files within the content directory and its subdirectories.
- `source: 'docs/**/*.yml'` includes all `YML` files within the `content/docs` and its subdirectories.
- `source: '**/*.{json,yml}'` includes `JSON` or `YML` file within the content directory and all its subdirectories.
- `source: '*.json'` includes only `JSON` files located directly within the content directory, excluding any subdirectories.

### `include` (required)

Glob pattern of your target repository and files in the content folder.

### `exclude`

Glob patterns to exclude content from the import.

### `prefix`

This configuration only applied for **page** type with 1-to-1 relationship between content files and pages on your site.

It represents the path prefix (base URL) of the corresponding page on the website.

<prose-warning>

The `prefix` must start by a leading `/`.

</prose-warning>

By default, module extracts the static prefix of `source`(or `source.include`) and uses it as a prefix for content paths. For example, if you define `/en/**` source, module will auto-fill the `prefix` with `/en`. You can manually provide a prefix to override this behavior. The prefix can be removed by setting `prefix: '/'` in the collection source.

```ts
defineCollection({
  type: "page",
  source: {
    include: "en/**",
    exclude: ["en/index.md"],
    prefix: '/'
  }
})
```

### `cwd`

Root directory for content matching.

**Example:**

If you want to include files from a folder outside the content directory, set the absolute path of that folder to the `cwd` property.

```ts
source: {
  cwd: path.resolve('packages/my-pkg/docs'),
  include: '**/*.md',
}
```

### `repository`

External source representing a remote git repository URL (e.g., [https://github.com/nuxt/content](https://github.com/nuxt/content)).

When defining an external source you must also define the `include` option.
`include` pattern is essential for the module to know which files to use for the collection.

```js
import { defineCollection, defineContentConfig } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    docs: defineCollection({
      type: 'page',
      source: {
        repository: 'https://github.com/nuxt/content',
        include: 'docs/content/**',
      },
    })
  }
})
```

### `authToken`

Authentication token for private repositories (e.g., GitHub personal access token).

<warning icon="i-lucide-shield-alert">

Never commit authentication tokens or credentials directly in your code. Use environment variables or other secure methods to provide these values at runtime.

</warning>

### `authBasic`

Basic authentication for private repositories (e.g., Bitbucket username and password).

```ts
defineCollection({
  type: 'page',
  source: {
    repository: 'https://bitbucket.org/username/repo',
    authBasic: {
      username: 'username',
      password: 'password',
    },
  },
})
```

# Markdown

> Create and query Markdown files in your Nuxt applications and use the MDC syntax to integrate Vue components.

## Usage

### Define a Collection

```ts [content.config.ts]
import { defineCollection, defineContentConfig, z } from '@nuxt/content'

export default defineContentConfig({
  collections: {
    blog: defineCollection({
      type: 'page',
      source: 'blog/*.md',
      schema: z.object({
        date: z.string()
      })
    })
  }
})
```

<note to="/docs/collections/types#page-type">

Learn more about the `page` collection type.

</note>

### Create `.md` files

Create blog posts in `content/blog/` directory.

<code-group>

```md [foo.md]
---
date: 2020-11-11
---

# Foo

This is Foo blog post.
```

```md [bar.md]
---
date: 2024-12-12
---
Hello
I am bar. Nice to meet you.
```

</code-group>

### Query Markdown Files

Now we can query blog posts:

```ts
// Get the foo post
const fooPost = await queryCollection('blog').path('/blog/foo').first()

// Find all posts
const allPosts = await queryCollection('blog').order('date', 'DESC').all()
```

### Display Markdown

To display the content of a markdown file, you can use the [`<ContentRenderer>`](/docs/components/content-renderer) component.

```vue [blog/[slug].vue]
<script setup>
const slug = useRoute().params.slug
const { data: post } = await useAsyncData(`blog-${slug}`, () => {
  return queryCollection('blog').path(`/blog/${slug}`).first()
})
</script>

<template>
  <!-- Render the blog post as Prose & Vue components -->
  <ContentRenderer :value="post" />
</template>
```

<note>

Read more about the [`<ContentRenderer>`](/docs/components/content-renderer) component and [`Prose Components`](/docs/components/prose).

</note>

## Frontmatter

Frontmatter is a convention of Markdown-based CMS to provide meta-data to pages, like description or title. In Nuxt Content, the frontmatter uses the YAML syntax with `key: value` pairs.

These data are available when rendering the content and can store any information that you would need.

### Syntax

You can declare a frontmatter block at the top of the Markdown files in the `content/` directory with the `---` identifier.

```md [content/index.md]
---
title: 'Title of the page'
description: 'meta description of the page'
---

<!-- Content of the page -->
```

```ts [example.ts]
const home = await queryCollection('content').path('/').first()

console.log(home.title)
// => 'Title of the page'
console.log(home.description)
// => 'meta description of the page'
console.log(home.body)
// => AST object of the page content
```

### Native parameters

<table>
<thead>
  <tr>
    <th>
      
    </th>
    
    <th>
      
    </th>
    
    <th>
      
    </th>
    
    <th>
      
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      Key
    </td>
    
    <td>
      Type
    </td>
    
    <td>
      Default
    </td>
    
    <td>
      Description
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        title
      </code>
    </td>
    
    <td>
      <code>
        string
      </code>
    </td>
    
    <td>
      First <code>
        <h1>
      </code>
      
       of the page
    </td>
    
    <td>
      Title of the page, will also be injected in metas
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        description
      </code>
    </td>
    
    <td>
      <code>
        string
      </code>
    </td>
    
    <td>
      First <code>
        <p>
      </code>
      
       of the page
    </td>
    
    <td>
      Description of the page, will be shown below the title and injected into the metas
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        navigation
      </code>
    </td>
    
    <td>
      <code>
        boolean
      </code>
    </td>
    
    <td>
      <code>
        true
      </code>
    </td>
    
    <td>
      Define if the page is included in <a href="/docs/utils/query-collection-navigation">
        <code>
          queryCollectionNavigation
        </code>
      </a>
      
       return value.
    </td>
  </tr>
</tbody>
</table>

<warning>

Additional parameters that you have defined in your frontmatter block need to be defined in your schema (see the date parameter in the example at top of this page) to be able to use them for querying.

</warning>

## MDC Syntax

We created the MDC syntax to supercharge Markdown and give you the ability to integrate Vue components with slots and props inside your Markdown.

<callout icon="i-simple-icons-visualstudiocode" to="https://marketplace.visualstudio.com/items?itemName=Nuxt.mdc">

Install the **MDC VS Code extension** to get proper syntax highlighting for the MDC syntax.

</callout>

### Vue Components

You can use any Vue component in your Markdown files.

We have a special syntax to make it easier to use components in your Markdown files.

```mdc [content/index.md]
::component-name
Default slot content
::
```

<warning>

Components that are used in Markdown has to be marked as `global` in your Nuxt app if you don't use the `components/content/` directory, visit [Nuxt 3 docs](https://nuxt.com/docs/guide/directory-structure/components) to learn more about it.

</warning>

#### Block Components

Block components are components that accept Markdown content or another component as a slot.

The component must contain at least one `<slot />` component to accept formatted text.

In a markdown file, use the component with the `::` identifier.

<code-group>

```mdc [index.md]
::card
The content of the card
::
```

```html [Card.vue]
<!-- components/content/Card.vue -->
<template>
  <div class="p-2 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <slot />
  </div>
</template>
```

<code-preview label="Preview" icon="i-lucide-eye">
<example-card>

The content of the card

</example-card>
</code-preview>
</code-group>

#### Slots

A component's slots can accept content or another components.

- **Default slot** renders the top-level content inside the block component or with `#default`
- **Named slots** use the `#` identifier to render the corresponding content.

<code-group>

```mdc [index.md]
::hero
My Page Title

#description
This will be rendered inside the `description` slot.
::
```

```html [Hero.vue]
<template>
  <section>
    <h1 class="text-4xl">
      <slot mdc-unwrap="p" />
    </h1>
    <slot name="description" />
  </section>
</template>
```

<code-preview label="Preview" icon="i-lucide-eye">
<example-hero>

My Page Title

<template v-slot:description="">

This will be rendered inside the `description` slot.

</template>
</example-hero>
</code-preview>
</code-group>

<note>

Read more about the [`<slot />`](/docs/components/slot) component.

</note>

<tip>

You can use Markdown inside your components slots:

<code-group>

```mdc [index.md]
::my-title
A [rich text](/) will be **rendered** by the component.
::
```

```html [MyTitle.vue]
<template>
  <h1 class="text-4xl">
    <slot mdc-unwrap="p" />
  </h1>
</template>
```

<code-preview label="Preview" icon="i-lucide-eye">
<example-title>

A [rich text](/) will be **rendered** by the component.

</example-title>
</code-preview>
</code-group>
</tip>

#### Props

There are two ways to pass props to components using MDC.

##### **Inline method**

The `{}` identifier passes props to components in a terse way by using a `key=value` syntax.

<code-group>

```mdc [index.md]
::alert{type="warning"}
The **alert** component.
::
```

```vue [Alert.vue]
<script setup>
const props = defineProps({ type: { type: String } })

const alertClass = computed(() => {
  return {
    warning: 'bg-orange-100 border-orange-200 dark:bg-orange-900 dark:border-orange-800',
    info: 'bg-blue-100 border-blue-200 dark:bg-blue-900 dark:border-blue-800',
    success: 'bg-green-100 border-green-200 dark:bg-green-900 dark:border-green-800',
  }[props.type]
})
</script>

<template>
  <div
    class="text-black p-2 border dark:text-white rounded"
    :class="alertClass"
  >
    <slot mdc-unwrap="p" />
  </div>
</template>
```

<code-preview label="Preview" icon="i-lucide-eye">
<example-alert type="warning">

The **alert** component.

</example-alert>
</code-preview>
</code-group>

Multiple props can be separated with a space:

```mdc
::alert{type="warning" icon="exclamation-circle"}
Oops! An error occurred
::
```

The `v-bind` shorthand `:` can be also be used to bind a prop to a value in the frontmatter.

```mdc
---
type: "warning"
---

::alert{:type="type"}
Your warning
::
```

If you want to pass arrays or objects as props to components you can pass them as JSON string and prefix the prop key with a colon to automatically decode the JSON string. Note that in this case you should use single quotes for the value string so you can use double quotes to pass a valid JSON string:

<code-group>

```mdc [array.md]
::dropdown{:items='["Nuxt", "Vue", "React"]'}
::
```

```mdc [number-array.md]
::dropdown{:items='[1,2,3.5]'}
::
```

```mdc [object.md]
::chart{:options='{"responsive": true, "scales": {"y": {"beginAtZero": true}}}'}
::
```

</code-group>

##### **YAML method**

The YAML method uses the `---` identifier to declare one prop per line, that can be useful for readability.

<code-group>

```mdc [index.md]
::icon-card
---
icon: IconNuxt
description: Harness the full power of Nuxt and the Nuxt ecosystem.
title: Nuxt Architecture.
---
::
```

```html [IconCard.vue]
<script setup>
defineProps({
  title: {
    type: String,
    default: 'Default title'
  },
  description: {
    type: String,
    default: 'Default description'
  },
  icon: {
    type: String,
    default: 'IconMarkdown'
  }
})
</script>

<template>
  <div class="p-6 border bg-white dark:bg-black dark:border-gray-700 rounded">
    <component :is="icon" class="w-20 h-20" />
    <h2 class="text-3xl font-semibold mb-2">
      {{ title }}
    </h2>
    <p>{{ description }}</p>
  </div>
</template>
```

<code-preview label="Preview" icon="i-lucide-eye">
<example-icon-card description="Harness the full power of Nuxt and the Nuxt ecosystem." icon="i-simple-icons-nuxtdotjs" title="Nuxt Architecture.">



</example-icon-card>
</code-preview>
</code-group>

### Attributes

Attributes are useful for highlighting and modifying part of paragraph. The syntax is nearly similar to inline components and markdown links syntax.

Possible values are all named attributes, classes with the notation `.class-name` and an ID with `#id-name`.

<code-group>

```mdc [index.md]
Hello [World]{style="color: green;" .custom-class #custom-id}!
```

<code-preview label="Preview" icon="i-lucide-eye">

Hello <span className="custom-class" id="custom-id" style="color: green;">

World

</span>

 !

</code-preview>
</code-group>

In addition to mdc components and `span`, attribute syntax will work on images, links, inline `code`, **bold** and _italic_ text.

<code-group>

```md [index.md]
Attributes work on:

- [link](#attributes){style="background-color: green;"}, `code`{style="color: cyan;"},
- _italic_{style="background-color: yellow; color:black;"} and **bold**{style="background-color: lightgreen;"} texts.
```

<code-preview label="Preview" :prose="true" prose="">

Attributes work on:

- [link](#attributes), `code`,
- *italic* and **bold** texts.

</code-preview>
</code-group>

### Binding Data

You can bind data within your Markdown document using the `{{ $doc.variable || 'defaultValue' }}` syntax. These values can be defined in the YAML frontmatter at the top of the document, within each MDC component, or injected using the `data` prop of the `<ContentRenderer>` component.

#### Define in YAML

```mdc
---
title: 'Title of the page'
description: 'meta description of the page'
customVariable: 'Custom Value'
---

# The Title is {{ $doc.title }} and customVariable is {{ $doc.customVariable || 'defaultValue' }}
```

#### Define in external with `<ContentRenderer>`

```html [test.vue]
<template>
  <div>
    <ContentRenderer :value="data" :data="mdcVars"/>
    <button type="button" v-on:click="mdcVars.name = 'Hugo'">Change name</button>
  </div>
</template>

<script setup lang="ts">
const { data } = await useAsyncData(() => queryCollection('content').path('/test').first());
const mdcVars = ref({ name: 'Maxime'});
</script>
```

```mdc [test.md]
# Hello {{ $doc.name || 'World' }}
```

## Prose Components

In Nuxt Content, the prose represents HTML tags generated by the Markdown syntax, such as heading levels and links.

For each HTML tag, a Vue component is used, allowing you to override them if needed, for example `<p>` becomes `<ProseP>`.

If you want to customize a Prose component, here are the recommended steps:

- Check out the original [component sources](https://github.com/nuxt-modules/mdc/blob/main/src/runtime/components/prose).
- Use the exact same props.
- In your `components/content/` directory, give it the same name.
- Make it yours 🚀.

<note to="/docs/components/prose">

Read the complete Prose reference in the Prose Components section.

</note>

## Code Highlighting

Nuxt Content uses [Shiki](https://github.com/shikijs/shiki), which colors tokens with VSCode themes.

Code highlighting works both on [`ProsePre`](/docs/components/prose#prosepre) and [`ProseCode`](/docs/components/prose#prosecodeinline).

Each line of a code block gets its line number in the `line` attribute so lines can be labeled or individually styled.

<callout>

[Read the API reference to configure or entirely disable syntax highlighting.](/docs/getting-started/configuration)

</callout>

## Images

You can add images to your `public` directory:

```bash [Directory structure]
content/
  index.md
public/
  image.png
nuxt.config.ts
package.json
```

And then use them in your markdown files in the `content` directory as such:

```md [content/index.md]
![my image](/image.png)
```

## Excerpt

Content excerpt or summary can be extracted from the content using `<!--more-->` as a divider.

```md [content/index.md]
---
title: Introduction
---

Learn how to use `@nuxt/content`.

<!--more-->

Full amount of content beyond the more divider.
```

Description property will contain the excerpt content unless defined within the frontmatter props.

If there is no `<!--more-->` divider in the text then excerpt is undefined.

<tip>

You should define the `excerpt` field in the collection schema if you want to use the excerpt feature.

```ts [content.config.ts]
const content = defineCollection({
  type: 'page',
  source: '**',
  schema: z.object({
    excerpt: z.object({
      type: z.string(),
      children: z.any(),
    }),
  }),
})
```

Read more about the [collection schema](/docs/collections/define#collection-schema).

</tip>

Example variables will be injected into the document:

```json
{
  "excerpt": Object
  "body": Object
  // ... other keys
}
```

# queryCollection

> The queryCollection composable provides methods for querying and fetching your collections.

## Usage

Use the auto-imported `queryCollection` to find contents inside a collection. Here we assume that you have defined `docs` collection inside `content.config.ts`.

If you have not defined any collection, check [How to define a collection](/docs/collections/define#defining-collections).

```vue [pages/[...slug].vue]
<script>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>
```

<tip>

The `queryCollection` utility is available in both Vue and Nitro. Checkout [Server Usage](#server-usage) for more details on how to use it on the server side.

</tip>

## API

### Type

```ts
function queryCollection<T extends keyof Collections>(collection: T): CollectionQueryBuilder<Collections[T]>

interface CollectionQueryBuilder<T> {
  where(field: keyof T | string, operator: SQLOperator, value?: unknown): CollectionQueryBuilder<T>
  andWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  orWhere(groupFactory: QueryGroupFunction<T>): CollectionQueryBuilder<T>
  order(field: keyof T, direction: 'ASC' | 'DESC'): CollectionQueryBuilder<T>
  // ... other methods
}
```

### `queryCollection(collection: CollectionName)`

Create a query builder to search in the specific collection.

- Parameter:

  - `collection`: The key of defined collection in `content.config.ts`

### `path(path: string)`

Search for contents that have specific `path`. (`path` is an special field in `page` collections which generates based on fs path and can be use as route to render the content)

- Parameter:

  - `path`: The path string to match.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
```

### `select(...fields: keyof Collection)`

Select specific fields from the collection to be returned in the query result.

- Parameters:

  - `...fields`: A list of field names to select from the collection.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .select('path', 'title', 'description')
    .first()
})
```

### `where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)`

Add a condition to the query to filter results based on a specific field.

- Parameters:

  - `field`: The field to filter on
  - `operator`: The SQL operator to use for comparison. Possible values include:
  
    - `'='`: Equal to
    - `'>'`: Greater than
    - `'<'`: Less than
    - `'<>'`: Not equal to
    - `'IN'`: In a list of values
    - `'BETWEEN'`: Between two values
    - `'NOT BETWEEN'`: Not between two values
    - `'IS NULL'`: Is null
    - `'IS NOT NULL'`: Is not null
    - `'LIKE'`: Matches a pattern
    - `'NOT LIKE'`: Does not match a pattern
  - `value`: The value to compare against. The type depends on the operator used.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    .where('category', '=', 'news')
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE date < '2024-04-04' AND category = 'news'
```

### `andWhere(groupFactory: QueryGroupFunction<Collection>)`

Add an AND condition group to the query. This allows for more complex query conditions.

- Parameter:

  - `groupFactory`: A function that receives a query builder and can add multiple conditions that will be grouped together with AND

```ts
const { data } = await useAsyncData('recent-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .andWhere(query => query.where('date', '>', '2024-01-01').where('category', '=', 'news'))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (date > '2024-01-01' AND category = 'news')
```

### `orWhere(groupFactory: QueryGroupFunction<Collection>)`

Add an OR condition group to the query. This allows for alternative conditions.

- Parameter:

  - `groupFactory`: A function that receives a query builder and can add multiple conditions that will be grouped together with OR

```ts
const { data } = await useAsyncData('featured-docs', () => {
  return queryCollection('docs')
    .where('published', '=', true)
    .orWhere(query => query.where('featured', '=', true).where('priority', '>', 5))
    .all()
})

// Generated SQL
// SELECT * FROM docs WHERE published = true AND (featured = true OR priority > 5)
```

### `order(field: keyof Collection, direction: 'ASC' | 'DESC')`

Order the query results based on a specific field.

- Parameters:

  - `field`: The field to order by.
  - `direction`: The direction of ordering, either 'ASC' for ascending or 'DESC' for descending.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .all()
})
```

### `limit(limit: number)`

Limit the number of results returned by the query.

- Parameter:

  - `limit`: The maximum number of results to return.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .limit(10)
    .all()
})
```

### `skip(skip: number)`

Skip a specified number of results in the query.

- Parameter:

  - `skip`: The number of results to skip.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // Skip first 5 items
    .skip(5)
    .all()
})
```

### `all()`

Execute the query and return all matching results.

- Returns: A Promise that resolves to an array of all matching documents.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').all()
})
```

### `first()`

Execute the query and return the first matching result.

- Returns: A Promise that resolves to the first matching document, or `null` if no documents match.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs').first()
})
```

### `count()`

Count the number of matched collection entries based on the query.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    // Count matches
    .count()
})

// Returns
5 // number of matches
```

You can also use `count()` with other methods defined above such as `where()` in order to apply additional conditions within the collection query.

```ts
const route = useRoute()
const { data } = await useAsyncData(route.path, () => {
  return queryCollection('docs')
    .where('date', '<', '2024-04-04')
    // Count matches
    .count()
})

// Returns
3 // number of matches for the provided query
```

## Examples

Here is a complete example of how to fetch a list of documents in the `docs` collections.

```vue [index.vue]
<script setup lang="ts">
const { data: docs } = await useAsyncData('documents-list', () => {
  return queryCollection('docs')
    .order('date', 'DESC')
    .select('title', 'path', 'description')
    .all()
})
</script>

<template>
  <NuxtLink v-for="doc in docs" :key="doc.path" :to="doc.path">
    <h2>{{ doc.title }}</h2>
    <p>{{ doc.description }}</p>
  </NuxtLink>
</template>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollection` function.

```ts [server/api/[slug].ts]
export default eventHandler(async (event) => {
  const { slug } = getRouterParams(event)
  const page = await queryCollection(event, 'docs').path(slug).first()
  return page
})
```

<note>

Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```

</note>

# queryCollectionNavigation

> The queryCollectionNavigation composable generates the navigation tree of given collection.

## Type

```ts
function queryCollectionNavigation<T extends keyof PageCollections>(
  collection: T,
  fields?: Array<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## Usage

Use the auto-imported `queryCollectionNavigation` to generate a navigation tree for a specific collection. This is particularly useful for creating dynamic navigation menus or sidebars based on your content structure.

The function returns a chainable promise that allows you to add additional query conditions:

```vue [pages/[...slug].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

<tip>

The `queryCollectionNavigation` utility is available in both Vue and Nitro. Checkout [Server Usage](#server-usage) for more details on how to use it on the server side.

</tip>

### Navigation metadata with `.navigation.yml`

You can add metadata to a directory using a `.navigation.yml` file.

```yml [.navigation.yml]
title: Getting Started
icon: i-lucide-square-play
```

## API

### `queryCollectionNavigation(collection: CollectionName, extraField: keyof Collection)`

Generate a navigation tree for the specified collection.

- Parameters:

  - `collection`: The key of the defined collection in `content.config.ts`.
  - `extraFields`: (Optional) An array of additional fields to include in the navigation items. (By default `title` and `path` are included in the navigation items.)
- Returns: A chainable promise that resolves to a navigation tree structure. The promise includes methods for adding query conditions:

  - `where(field, operator, value)`: Add a WHERE condition
  - `andWhere(groupFactory)`: Add a grouped AND condition
  - `orWhere(groupFactory)`: Add a grouped OR condition
  - `order(field, direction)`: Add an ORDER BY clause

The navigation tree is generated based on the directory structure and ordering happens based on files [ordering](/docs/collections/types#ordering-files)

## Examples

Basic usage without additional query conditions:

```vue [pages/[...slug].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">{{ item.title }}</NuxtLink>
      </li>
    </ul>
  </nav>
</template>
```

Example with additional query conditions and extra fields:

```vue [pages/[...slug].vue]
<script setup lang="ts">
const { data } = await useAsyncData('navigation', () => {
  return queryCollectionNavigation('docs', ['description', 'badge'])
    .where('draft', '=', false)
    .where('partial', '=', false)
    .order('title', 'ASC')
})
</script>

<template>
  <nav>
    <ul v-if="data">
      <li v-for="item in data" :key="item.path">
        <NuxtLink :to="item.path">
          {{ item.title }}
          <span v-if="item.badge" class="badge">{{ item.badge }}</span>
        </NuxtLink>
        <p v-if="item.description">{{ item.description }}</p>
      </li>
    </ul>
  </nav>
</template>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollectionNavigation` function.

```ts [server/api/navigation.ts]
export default eventHandler(async (event) => {
  const navigation = await queryCollectionNavigation(event, 'docs')
  return navigation
})
```

<note>

Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```

</note>

---

## Extra utilities to work with navigation

Content module provides some extra utilities to simplify common use cases like building breadcrumb navigation.

### `findPageHeadline(navigation, path, options?)`

Returns the headline (name of the parent folder) for a given path within a navigation tree. Useful for displaying section titles or contextual navigation headers.

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The current page path.
- `options` (optional):

  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageHeadline } from '@nuxt/content/utils'

const headline = findPageHeadline(navigation, '/docs/guide/getting-started')
// headline is a string that contains the name of the parent folder
```

### `findPageBreadcrumb(navigation, path, options?)`

Returns the breadcrumb trail (array of navigation items) for a given path within a navigation tree. Useful for building breadcrumb navigation components.

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The current page path.
- `options` (optional):

  - `current`: Include the current page in the breadcrumb.
  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageBreadcrumb } from '@nuxt/content/utils'

const breadcrumb = findPageBreadcrumb(navigation, '/docs/guide/getting-started')
// breadcrumb is an array of navigation items leading to the current page
```

### `findPageChildren(navigation, path, options?)`

Finds and returns the direct children of a given path in the navigation tree.

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The parent path to find children for.
- `options` (optional):

  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageChildren } from '@nuxt/content/utils'

const children = findPageChildren(navigation, '/docs/guide')
// children is an array of navigation items under '/docs/guide'
```

### `findPageSiblings(navigation, path, options?)`

Returns the sibling navigation items for a given path (i.e., other items with the same parent).

- `navigation`: The navigation tree (array of ContentNavigationItem).
- `path`: The current page path.
- `options` (optional):

  - `indexAsChild`: Treat index pages as children.

**Example:**

```ts
import { findPageSiblings } from '@nuxt/content/utils'

const siblings = findPageSiblings(navigation, '/docs/guide/getting-started')
// siblings is an array of navigation items that share the same parent as the current page
```

# queryCollectionItemSurroundings

> The queryCollectionItemSurroundings composable looks for sibling contents of an specific path.

## Type

```ts
function queryCollectionItemSurroundings<T extends keyof PageCollections>(
  collection: T,
  path: string,
  opts?: SurroundOptions<keyof PageCollections[T]>
): ChainablePromise<T, ContentNavigationItem[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## Usage

Use the auto-imported `queryCollectionItemSurroundings` to find the previous and next items relative to a specific content item in a collection. This is particularly useful for creating navigation between related content pages.

The function returns a chainable promise that allows you to add additional query conditions:

```vue [pages/[...slug].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
    .where('published', '=', true)
    .order('date', 'DESC')
})
</script>
```

<tip>

The `queryCollectionItemSurroundings` utility is available in both Vue and Nitro. Checkout [Server Usage](#server-usage) for more details on how to use it on the server side.

</tip>

## API

### `queryCollectionItemSurroundings(collection: CollectionName, path: string, opts?: SurroundOptions)`

Find the surrounding items (previous and next) for a specific content item in a collection.

- Parameters:

  - `collection`: The key of the defined collection in `content.config.ts`.
  - `path`: The path of the current content item.
  - `opts`: (Optional) An object with the following properties:
  
    - `before`: (Optional) The number of items to fetch before the current item. Default is 1.
    - `after`: (Optional) The number of items to fetch after the current item. Default is 1.
    - `fields`: (Optional) An array of additional fields to include in the surrounding items.
- Returns: A chainable promise that resolves to an array containing the surrounding items. The promise includes methods for adding query conditions:

  - `where(field, operator, value)`: Add a WHERE condition
  - `andWhere(groupFactory)`: Add a grouped AND condition
  - `orWhere(groupFactory)`: Add a grouped OR condition
  - `order(field, direction)`: Add an ORDER BY clause

The final result will be an array with the following structure:

- `[previousItem, nextItem]` if using default options
- `[...previousItems, ...nextItems]` if using custom `before` and `after` values

Each item in the array is of type `ContentNavigationItem` or `null` if there is no item in that position.

## Examples

Basic usage without additional query conditions:

```vue [pages/[...slug].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo')
})
</script>

<template>
  <div class="flex justify-between">
    <NuxtLink v-if="data?.[0]" :to="data[0].path">
      ← {{ data[0].title }}
    </NuxtLink>
    <NuxtLink v-if="data?.[1]" :to="data[1].path">
      {{ data[1].title }} →
    </NuxtLink>
  </div>
</template>
```

Example with additional query conditions:

```vue [pages/[...slug].vue]
<script setup lang="ts">
const { data } = await useAsyncData('surround', () => {
  return queryCollectionItemSurroundings('docs', '/foo', {
    before: 1,
    after: 1,
    fields: ['badge', 'description']
  })
    .where('_draft', '=', false)
    .where('_partial', '=', false)
    .order('date', 'DESC')
})
</script>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollectionItemSurroundings` function.

```ts [server/api/surroundings.ts]
export default eventHandler(async (event) => {
  const surroundings = await queryCollectionItemSurroundings(event, 'docs', '/foo')
  return surroundings
})
```

<note>

Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```

</note>

# queryCollectionSearchSections

> The queryCollectionSearchSections composable generates searchable sections from a collection for enhanced content discovery.

## Type

```ts
function queryCollectionSearchSections(collection: keyof Collections, opts?: { ignoredTags: string[] }): ChainablePromise<T, Section[]>

interface ChainablePromise<T extends keyof PageCollections, R> extends Promise<R> {
  where(field: keyof PageCollections[T] | string, operator: SQLOperator, value?: unknown): ChainablePromise<T, R>
  andWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  orWhere(groupFactory: QueryGroupFunction<PageCollections[T]>): ChainablePromise<T, R>
  order(field: keyof PageCollections[T], direction: 'ASC' | 'DESC'): ChainablePromise<T, R>
}
```

## Usage

Use the auto-imported `queryCollectionSearchSections` to generate searchable sections from a specific collection. This is particularly useful for creating advanced search functionality or content discovery features in your application.

```vue [app.vue]
<script>
const { data: sections } = await useAsyncData('search-sections', () => {
  return queryCollectionSearchSections('docs')
})
</script>
```

<tip>

The `queryCollectionSearchSections` utility is available in both Vue and Nitro. Checkout [Server Usage](#server-usage) for more details on how to use it on the server side.

</tip>

## API

### `queryCollectionSearchSections(collection: CollectionName, options?: SearchSectionsOptions)`

Generate searchable sections from the specified collection.

- Parameters:

  - `collection`: The key of the defined collection in `content.config.ts`.
  - `options`: (Optional) An object with the following properties:
  
    - `ignoredTags`: An array of tag names to ignore when generating sections. Default is an empty array.
- Returns: A Promise that resolves to an array of searchable sections. Each section is an object with the following properties:

  - `id`: A unique identifier for the section.
  - `title`: The title of the section (usually the heading text).
  - `titles`: An array of parent section titles, representing the hierarchy.
  - `content`: The textual content of the section.
  - `level`: The heading level (1-6) of the section, where 1 is the highest level.

## Example

Here's an example of how to use `queryCollectionSearchSections` to create searchable sections from the 'docs' collection:

```vue [pages/[...slug].vue]
<script>
const { data: surround } = await useAsyncData('foo-surround', () => {
  return queryCollectionSearchSections('docs', {
    ignoredTags: ['code']
  })
})
</script>
```

## Server Usage

Nuxt Content provides a similar utility to query collections on the server side. The only difference is that you need to pass `event` as the first argument to the `queryCollectionSearchSections` function.

```ts [server/api/search-sections.ts]
export default eventHandler(async (event) => {
  const sections = await queryCollectionSearchSections(event, 'docs')
  return sections
})
```

<note>

Make sure to create `server/tsconfig.json` file with the following content to avoid type error.

```json
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```

</note>
# ContentRenderer

> Takes your component from an AST to a wonderful template.

The `<ContentRenderer>` component renders a document coming from a query with [`queryCollection()`](/docs/utils/query-collection).

<note>

This component **only works** with `Markdown` files.

</note>

## Props

<table>
<thead>
  <tr>
    <th>
      Prop
    </th>
    
    <th>
      Default
    </th>
    
    <th>
      Type
    </th>
    
    <th>
      Description
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      <code>
        value
      </code>
    </td>
    
    <td>
      <code>
        {}
      </code>
    </td>
    
    <td>
      <code>
        ParsedContent
      </code>
    </td>
    
    <td>
      The document to render.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        tag
      </code>
    </td>
    
    <td>
      <code>
        'div'
      </code>
    </td>
    
    <td>
      <code>
        string
      </code>
    </td>
    
    <td>
      The tag to use for the renderer element if it is used.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        excerpt
      </code>
    </td>
    
    <td>
      <code>
        false
      </code>
    </td>
    
    <td>
      <code>
        boolean
      </code>
    </td>
    
    <td>
      Whether to render the excerpt only without the rest of the content.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        components
      </code>
    </td>
    
    <td>
      <code>
        {}
      </code>
    </td>
    
    <td>
      <code>
        object
      </code>
    </td>
    
    <td>
      The map of custom components to use for rendering. This prop will pass to the markdown renderer and will not affect other file types.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        data
      </code>
    </td>
    
    <td>
      <code>
        {}
      </code>
    </td>
    
    <td>
      <code>
        object
      </code>
      
       (required)
    </td>
    
    <td>
      A map of variables to inject into the markdown content for later use in binding variables.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        prose
      </code>
    </td>
    
    <td>
      <code>
        undefined
      </code>
    </td>
    
    <td>
      <code>
        boolean
      </code>
    </td>
    
    <td>
      Whether or not to render Prose components instead of HTML tags.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        class
      </code>
    </td>
    
    <td>
      <code>
        undefined
      </code>
    </td>
    
    <td>
      <code>
        string
      </code>
      
       or <code>
        object
      </code>
    </td>
    
    <td>
      Root tag to use for rendering.
    </td>
  </tr>
  
  <tr>
    <td>
      <code>
        unwrap
      </code>
    </td>
    
    <td>
      <code>
        false
      </code>
    </td>
    
    <td>
      <code>
        boolean
      </code>
      
       or <code>
        string
      </code>
    </td>
    
    <td>
      Tags to unwrap separated by spaces. Example: <code>
        'ul li'
      </code>
      
      .
    </td>
  </tr>
</tbody>
</table>

## Example Usage

```vue [pages/[...slug].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <ContentRenderer v-if="page" :value="page" />
</template>
```

## Handling Missing Pages

If the queried content is **missing**, you can display a **custom fallback message**.

```vue [pages/[...slug].vue]
<script lang="ts" setup>
const route = useRoute()
const { data: page } = await useAsyncData(route.path, () => {
  return queryCollection('docs').path(route.path).first()
})
</script>

<template>
  <template v-if="page">
    <ContentRenderer :value="page" />
  </template>
  <template v-else>
    <div class="empty-page">
      <h1>Page Not Found</h1>
      <p>Oops! The content you're looking for doesn't exist.</p>
      <NuxtLink to="/">Go back home</NuxtLink>
    </div>
  </template>
</template>
```

## Handling Empty Pages

If the queried content is **empty**, you can display a **custom fallback message**.

# Slot

> The fastest way to inject Markdown into your Vue components.

When you write contents and paragraphs inside a component with the MDC syntax, you can use Vue's `<slot>` component to render the content.

## Usage

If you don't want to modify the rendered content, simply use Vue's `<slot>` component.

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot />
  </div>
</template>
```

Now let's use it in Markdown:

```mdc [content/index.md]
::callout
This is a callout.
::
```

The rendered HTML will be:

```html
<div class="callout">
  <p>This is a callout.</p>
</div>
```

This usage would be similar to using the native `<slot>` component.

### Unwrapping

The `mdc-unwrap` prop allows you to remove one or multiple wrapping elements from the rendered content. This is useful when you want to extract the content nested in native Markdown syntax. Each specified tag will get removed from AST.

Let's unwrap the `<p>` element from the previous example:

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <slot mdc-unwrap="p" />
  </div>
</template>
```

Now the rendered HTML will be:

```html
<div class="callout">
  This is a callout.
</div>
```

### Named Slots

The `name` prop allows you to bind a slot by its name. This is useful when you want to render a slot that is not the default one.

Let's improve our `Callout` component to have a `title` slot:

```vue [components/content/Callout.vue]
<template>
  <div class="callout">
    <h2 v-if="$slots.title">
      <slot name="title" mdc-unwrap="p" />
    </h2>
    <slot />
  </div>
</template>
```

Now let's use it in Markdown:

```mdc [content/index.md]
::callout
#title
Please be careful!
#default
Using MDC & Vue components is addictive.
::
```

This will result into:

```html
<div class="callout">
  <h2>Please be careful!</h2>
  <p>Using MDC & Vue components is addictive.</p>
</div>
```

When not using the `title` slot, the `h2` element will not be rendered.

## Props

- `mdc-unwrap`: Whether to unwrap the content or not. This is useful when you want to extract the content nested in native Markdown syntax. Each specified tag will get removed from AST.

  - **Type:** `boolean` or `string`
  - **Default:** `false`
  - **Example:** `'p'` or `'ul li'`

  # Prose Components

> A list of Prose components.

Prose components are replacements for HTML typography tags. Prose components provide a simple way to customize content UI.

To overwrite a prose component, create a component with the same name in your project `components/content/` directory (ex: `components/content/ProseA.vue`).

<note>

Prose components are originally part of [`@nuxtjs/mdc`](https://github.com/nuxt-modules/mdc).

</note>

## `ProseA`

<code-group>

```md [Code]
[Link](/docs/components/prose)
```

<code-preview label="Preview" icon="i-lucide-eye">

[Link](/docs/components/prose)

</code-preview>
</code-group>

## `ProseBlockquote`

<code-group>

```md [Code]
> Block quote
```

<code-preview label="Preview" icon="i-lucide-eye">

> Block quote

</code-preview>
</code-group>

## `ProsePre`

<code-group>

```md [Code]
```js [file.js]{2} meta-info=val
  export default () => {
    console.log('Code block')
  }
  ```
```

<code-preview label="Preview" icon="i-lucide-eye">

```js [file.js]
export default () => {
  console.log('Code block')
}
```

</code-preview>
</code-group>

Component properties will be:

```json
{
  code: "export default () => {\n    console.log('Code block')\n}"
  language: "js"
  filename: "file.js"
  highlights: [2]
  meta: "meta-info=val"
}
```

Check out the [highlight options](/docs/getting-started/configuration#highlight) for more about the syntax highlighting.

<callout type="warning">

If you want to use `]` in the filename, you need to escape it with 2 backslashes: `\\]`. This is necessary since JS will automatically escape the backslash in a string so `\]` will be resolved as `]` breaking our regex.

</callout>

## `ProseCode`

<code-group>

```md [Code]
`code`

`const code: string = 'highlighted code inline'`{lang="ts"}
```

<code-preview label="Preview" icon="i-lucide-eye">

`code`

`const code: string = 'highlighted code inline'`

</code-preview>
</code-group>

## `ProseH1`

<code-group>

```md [Code]
# H1 Heading
```

<code-preview label="Preview" className="pt-4">

# H1 Heading

</code-preview>
</code-group>

## `ProseH2`

<code-group>

```md [Code]
## H2 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

## H2 Heading

</code-preview>
</code-group>

## `ProseH3`

<code-group>

```md [Code]
### H3 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

### H3 Heading

</code-preview>
</code-group>

## `ProseH4`

<code-group>

```md [Code]
#### H4 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

#### H4 Heading

</code-preview>
</code-group>

## `ProseH5`

<code-group>

```md [Code]
##### H5 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

##### H5 Heading

</code-preview>
</code-group>

## `ProseH6`

<code-group>

```md [Code]
###### H6 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

###### H6 Heading

</code-preview>
</code-group>

## `ProseHr`

<code-group>

```md [Code]
Divider under.

---

Divider above.
```

<code-preview label="Preview" icon="i-lucide-eye">

Divider under.

---

Divider above.

</code-preview>
</code-group>

## `ProseImg`

<code-group>

```md [Code]
![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)
```

<code-preview label="Preview" icon="i-lucide-eye">

![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)

</code-preview>
</code-group>

## `ProseUl`

<code-group>

```md [Code]
- Just
- An
- Unordered
- List
```

<code-preview label="Preview" icon="i-lucide-eye">

- Just
- An
- Unordered
- List

</code-preview>
</code-group>

## `ProseLi`

<code-group>

```md [Code]
- List element
```

<code-preview label="Preview" icon="i-lucide-eye">

- List element

</code-preview>
</code-group>

## `ProseOl`

<code-group>

```md [Code]
1. Foo
2. Bar
3. Baz
```

<code-preview label="Preview" icon="i-lucide-eye">

1. Foo
2. Bar
3. Baz

</code-preview>
</code-group>

## `ProseP`

<code-group>

```md [Code]
Just a paragraph.
```

<code-preview label="Preview" icon="i-lucide-eye">

Just a paragraph.

</code-preview>
</code-group>

## `ProseStrong`

<code-group>

```md [Code]
**Just a strong paragraph.**
```

<code-preview label="Preview" icon="i-lucide-eye">

**Just a strong paragraph.**

</code-preview>
</code-group>

## `ProseEm`

<code-group>

```md [Code]
_Just an italic paragraph._
```

<code-preview label="Preview" icon="i-lucide-eye">

*Just an italic paragraph.*

</code-preview>
</code-group>

## `ProseTable`

<code-group>

```md [Code]
| Key | Type      | Description |
| --- | --------- | ----------- |
| 1   | Wonderful | Table       |
| 2   | Wonderful | Data        |
| 3   | Wonderful | Website     |
```

<code-preview label="Preview" icon="i-lucide-eye">
<table>
<thead>
  <tr>
    <th>
      Key
    </th>
    
    <th>
      Type
    </th>
    
    <th>
      Description
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      1
    </td>
    
    <td>
      Wonderful
    </td>
    
    <td>
      Table
    </td>
  </tr>
  
  <tr>
    <td>
      2
    </td>
    
    <td>
      Wonderful
    </td>
    
    <td>
      Data
    </td>
  </tr>
  
  <tr>
    <td>
      3
    </td>
    
    <td>
      Wonderful
    </td>
    
    <td>
      Website
    </td>
  </tr>
</tbody>
</table>
</code-preview>
</code-group>

## `ProseTbody`

Included in **ProseTable** example.

## `ProseTd`

Included in **ProseTable** example.

## `ProseTh`

Included in **ProseTable** example.

## `ProseThead`

Included in **ProseTable** example.

## `ProseTr`

Included in **ProseTable** example.

<callout icon="i-simple-icons-github" to="https://github.com/nuxt-modules/mdc/tree/main/src/runtime/components/prose">

Checkout the source code for these components on GitHub.

</callout>


# Setup Nuxt Studio

> Studio is the intuitive CMS interface to edit Nuxt Content websites. Edit your Markdown, YAML and JSON files and publish your changes to GitHub.

Studio is an intuitive CMS interface to edit your Nuxt Content websites.

It takes advantage of the `Preview API` included in Nuxt Content to propose the best editing experience for your content files. Editors can benefit from a user-friendly interface to edit their `Markdown`, `YAML` or `JSON` files.

Developers can customize the editing experience and provide tools to the editor who can focus on content without requiring any technical expertise.

<video :autoplay="true" :controls="true" :loop="true" poster="/home/videos/HomeNotionLikePoster.webp" src="https://res.cloudinary.com/nuxt/video/upload/v1733494722/contentv3final_rc8bvu.mp4">



</video>

## Authentication

The Studio admin is located on [nuxt.studio](https://nuxt.studio). From there you can either login with GitHub or with Google. Both methods give you the same editing rights but since Studio is [synchronized with GitHub](/docs/studio/github), the repository import must be handled by a GitHub user.

<warning>

Google authentication is adapted for non technical users. Google users have to join a team with existing projects to edit them.

</warning>

## Connect your Nuxt Content Repository

Once you are logged in the admin, you have the possibility to import your Nuxt Content repository from the interface.

<tip>

Two options are available, you can either import an existing repository or use one of our [templates](/templates).

</tip>

The only requirement is to host your repository on GitHub. From the interface, connect to our [GitHub app](/docs/studio/github), you'll be then able to link a GitHub repository to your Studio project.

Once the project is created, you can start editing your files with the Studio editors and publish your changes.

## **Enable the Full Editing Experience**

To unlock the complete range of features in Studio, make sure your project URL is properly configured in the deployment section.

**This will enable all Studio features including:**

- **Live preview of your website:** instantly see changes reflected on your site as you work.
- **Dynamic form generation:** Automatically generate forms to edit your files based on your Nuxt Content [collections](/docs/collections/define).
- **Enhanced markdown editors:** enjoy an improved editing experience, including the ability to list and integrate [Vue components](/docs/studio/content#vue-components) that you’ve exposed.
- **Automatic app configuration:** generate [application configurations](/docs/studio/config) based on the schema you’ve defined.

<tip>

We are proposing a GitHub Pages deployment. By using it, we will handle all the requirements for you. However, if you want to use the deployment platform of your choice, please follow the simple guideline below.

</tip>

To be able to set your URL in Studio, you just need to set the `Preview API` in the content configuration of your `nuxt.config.ts` file.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio'
    }
  }
})
```

Once deployed, you can ensure the `Preview API` has been activated by navigating to the `/__preview.json` page on your site. This metadata page is automatically generated by the Content module and must be accessible to connect your URL in the self-hosted section of Studio.

### Troubleshooting

The `__preview.json` file is generated but you encounter a `Forbidden error: invalid property check` when setting your URL in the self-hosted section, follow these steps:

<prose-steps level="4">

#### Ensure the `gitInfo` field is set and accurate in the `__preview.json` file

```json [https://your-website.com/__preview.json]
"gitInfo": {
  "name": "content",
  "owner": "nuxt",
  "url": "https://github.com/nuxt/content"
},
```

<warning>

This information should be populated automatically in most cases. We support most popular providers (NuxtHub, Vercel, Netlify, etc.), but if you're using a non supported provider or a custom one, it may not be fetched correctly.

</warning>

#### Override `gitInfo` in your `nuxt.config.ts`

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  content: {
    preview: {
      api: 'https://api.nuxt.studio',
      gitInfo: {
        name: 'Your repository name',
        owner: 'Your repository owner/organization',
        url: 'Your GitHub repository URL'
      }
    }
  }
})
```

#### Ensure these fields are correctly set in `__preview.json`

The `Forbidden error` should be resolved and you should be able to set your URL on Nuxt Studio. If not, please contact us on the [Discord server](https://discord.gg/sBXDm6e8SP).

</prose-steps>


# SEO and Meta

> Improve your Nuxt app's SEO with powerful head config, composables and components.

Nuxt head tag management is powered by [Unhead](https://unhead.unjs.io). It provides sensible defaults, several powerful composables
and numerous configuration options to manage your app's head and SEO meta tags.

## Nuxt Config

Providing an [`app.head`](/docs/4.x/api/nuxt-config#head) property in your [`nuxt.config.ts`](/docs/4.x/guide/directory-structure/nuxt-config) allows you to statically customize the head for your entire app.

<important>

This method does not allow you to provide reactive data. We recommend using `useHead()` in `app.vue`.

</important>

It's good practice to set tags here that won't change such as your site title default, language and favicon.

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    head: {
      title: 'Nuxt', // default fallback title
      htmlAttrs: {
        lang: 'en',
      },
      link: [
        { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' },
      ]
    }
  }
})
```

You can also provide any of the keys listed below in [Types](#types).

### Defaults Tags

Some tags are provided by Nuxt by default to ensure your website works well out of the box.

- `viewport`: `width=device-width, initial-scale=1`
- `charset`: `utf-8`

While most sites won't need to override these defaults, you can update them using the keyed shortcuts.

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    head: {
      // update Nuxt defaults
      charset: 'utf-16',
      viewport: 'width=device-width, initial-scale=1, maximum-scale=1',
    }
  }
})
```

## `useHead`

The [`useHead`](/docs/4.x/api/composables/use-head) composable function supports reactive input, allowing you to manage your head tags programmatically.

```vue [app.vue]twoslash
<script setup lang="ts">
useHead({
  title: 'My App',
  meta: [
    { name: 'description', content: 'My amazing site.' }
  ],
  bodyAttrs: {
    class: 'test'
  },
  script: [ { innerHTML: 'console.log(\'Hello world\')' } ]
})
</script>
```

We recommend taking a look at the [`useHead`](/docs/4.x/api/composables/use-head) and [`useHeadSafe`](/docs/4.x/api/composables/use-head-safe) composables.

## `useSeoMeta`

The [`useSeoMeta`](/docs/4.x/api/composables/use-seo-meta) composable lets you define your site's SEO meta tags as an object with full type safety.

This helps you avoid typos and common mistakes, such as using `name` instead of `property`.

```vue [app.vue]twoslash
<script setup lang="ts">
useSeoMeta({
  title: 'My Amazing Site',
  ogTitle: 'My Amazing Site',
  description: 'This is my amazing site, let me tell you all about it.',
  ogDescription: 'This is my amazing site, let me tell you all about it.',
  ogImage: 'https://example.com/image.png',
  twitterCard: 'summary_large_image',
})
</script>
```

<read-more to="/docs/api/composables/use-seo-meta">



</read-more>

## Components

While using [`useHead`](/docs/4.x/api/composables/use-head) is recommended in all cases, you may have a personal preference for defining your head tags in your template using components.

Nuxt provides the following components for this purpose: `<Title>`, `<Base>`, `<NoScript>`, `<Style>`, `<Meta>`, `<Link>`, `<Body>`, `<Html>` and `<Head>`. Note
the capitalization of these components ensuring we don't use invalid native HTML tags.

`<Head>` and `<Body>` can accept nested meta tags (for aesthetic reasons) but this does not affect *where* the nested meta tags are rendered in the final HTML.

```vue [app.vue]
<script setup lang="ts">
const title = ref('Hello World')
</script>

<template>
  <div>
    <Head>
      <Title>{{ title }}</Title>
      <Meta name="description" :content="title" />
      <Style>
      body { background-color: green; }
      </Style>
    </Head>

    <h1>{{ title }}</h1>
  </div>
</template>
```

It's suggested to wrap your components in either a `<Head>` or `<Html>` components as tags will be deduped more intuitively.

## Types

Below are the non-reactive types used for [`useHead`](/docs/4.x/api/composables/use-head), [`app.head`](/docs/4.x/api/nuxt-config#head) and components.

```ts
interface MetaObject {
  title?: string
  titleTemplate?: string | ((title?: string) => string)
  templateParams?: Record<string, string | Record<string, string>>
  base?: Base
  link?: Link[]
  meta?: Meta[]
  style?: Style[]
  script?: Script[]
  noscript?: Noscript[];
  htmlAttrs?: HtmlAttributes;
  bodyAttrs?: BodyAttributes;
}
```

See [@unhead/vue](https://github.com/unjs/unhead/blob/main/packages/vue/src/types/schema.ts) for more detailed types.

## Features

### Reactivity

Reactivity is supported on all properties, by providing a computed value, a getter, or a reactive object.

<code-group>

```vue [useHead]twoslash
<script setup lang="ts">
const description = ref('My amazing site.')

useHead({
  meta: [
    { name: 'description', content: description }
  ],
})
</script>
```

```vue [useSeoMeta]twoslash
<script setup lang="ts">
const description = ref('My amazing site.')

useSeoMeta({
  description
})
</script>
```

```vue [Components]
<script setup lang="ts">
const description = ref('My amazing site.')
</script>

<template>
  <div>
    <Meta name="description" :content="description" />
  </div>
</template>
```

</code-group>

### Title Template

You can use the `titleTemplate` option to provide a dynamic template for customizing the title of your site. For example, you could add the name of your site to the title of every page.

The `titleTemplate` can either be a string, where `%s` is replaced with the title, or a function.

If you want to use a function (for full control), then this cannot be set in your `nuxt.config`. It is recommended instead to set it within your `app.vue` file where it will apply to all pages on your site:

<code-group>

```vue [useHead]twoslash
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';
  }
})
</script>
```

</code-group>

Now, if you set the title to `My Page` with [`useHead`](/docs/4.x/api/composables/use-head) on another page of your site, the title would appear as 'My Page - Site Title' in the browser tab. You could also pass `null` to default to 'Site Title'.

### Template Params

You can use `templateParams` to provide additional placeholders in your `titleTemplate` besides the default `%s`. This allows for more dynamic title generation.

<code-group>

```vue [useHead]twoslash
<script setup lang="ts">
useHead({
  titleTemplate: (titleChunk) => {
    return titleChunk ? `${titleChunk} %separator %siteName` : '%siteName';
  },
  templateParams: {
    siteName: 'Site Title',
    separator: '-'
  }
})
</script>
```

</code-group>

### Body Tags

You can use the `tagPosition: 'bodyClose'` option on applicable tags to append them to the end of the `<body>` tag.

For example:

```vuetwoslash
<script setup lang="ts">
useHead({
  script: [
    {
      src: 'https://third-party-script.com',
      // valid options are: 'head' | 'bodyClose' | 'bodyOpen'
      tagPosition: 'bodyClose'
    }
  ]
})
</script>
```

## Examples

### With `definePageMeta`

Within your [`pages/` directory](/docs/4.x/guide/directory-structure/pages), you can use `definePageMeta` along with [`useHead`](/docs/4.x/api/composables/use-head) to set metadata based on the current route.

For example, you can first set the current page title (this is extracted at build time via a macro, so it can't be set dynamically):

```vue [pages/some-page.vue]twoslash
<script setup lang="ts">
definePageMeta({
  title: 'Some Page'
})
</script>
```

And then in your layout file, you might use the route's metadata you have previously set:

```vue [layouts/default.vue]twoslash
<script setup lang="ts">
const route = useRoute()

useHead({
  meta: [{ property: 'og:title', content: `App Name - ${route.meta.title}` }]
})
</script>
```

<link-example to="/docs/examples/features/meta-tags">



</link-example>

<read-more to="/docs/guide/directory-structure/pages/#page-metadata">



</read-more>

### Dynamic Title

In the example below, `titleTemplate` is set either as a string with the `%s` placeholder or as a `function`, which allows greater flexibility in setting the page title dynamically for each route of your Nuxt app:

```vue [app.vue]twoslash
<script setup lang="ts">
useHead({
  // as a string,
  // where `%s` is replaced with the title
  titleTemplate: '%s - Site Title',
})
</script>
```

```vue [app.vue]twoslash
<script setup lang="ts">
useHead({
  // or as a function
  titleTemplate: (productCategory) => {
    return productCategory
      ? `${productCategory} - Site Title`
      : 'Site Title'
  }
})
</script>
```

`nuxt.config` is also used as an alternative way of setting the page title. However, `nuxt.config` does not allow the page title to be dynamic. Therefore, it is recommended to use `titleTemplate` in the `app.vue` file to add a dynamic title, which is then applied to all routes of your Nuxt app.

### External CSS

The example below shows how you might enable Google Fonts using either the `link` property of the [`useHead`](/docs/4.x/api/composables/use-head) composable or using the `<Link>` component:

<code-group>

```vue [useHead]twoslash
<script setup lang="ts">
useHead({
  link: [
    {
      rel: 'preconnect',
      href: 'https://fonts.googleapis.com'
    },
    {
      rel: 'stylesheet',
      href: 'https://fonts.googleapis.com/css2?family=Roboto&display=swap',
      crossorigin: ''
    }
  ]
})
</script>
```

```vue [Components]
<template>
  <div>
    <Link rel="preconnect" href="https://fonts.googleapis.com" />
    <Link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" crossorigin="" />
  </div>
</template>
```

</code-group>


# Assets

> Nuxt offers two options for your assets.

Nuxt uses two directories to handle assets like stylesheets, fonts or images.

- The [`public/`](/docs/4.x/guide/directory-structure/public) directory content is served at the server root as-is.
- The [`assets/`](/docs/4.x/guide/directory-structure/assets) directory contains by convention every asset that you want the build tool (Vite or webpack) to process.

## Public Directory

The [`public/`](/docs/4.x/guide/directory-structure/public) directory is used as a public server for static assets publicly available at a defined URL of your application.

You can get a file in the [`public/`](/docs/4.x/guide/directory-structure/public) directory from your application's code or from a browser by the root URL `/`.

### Example

For example, referencing an image file in the `public/img/` directory, available at the static URL `/img/nuxt.png`:

```vue [app.vue]
<template>
  <img src="/img/nuxt.png" alt="Discover Nuxt" />
</template>
```

## Assets Directory

Nuxt uses [Vite](https://vite.dev/guide/assets.html) (default) or [webpack](https://webpack.js.org/guides/asset-management) to build and bundle your application. The main function of these build tools is to process JavaScript files, but they can be extended through [plugins](https://vite.dev/plugins) (for Vite) or [loaders](https://webpack.js.org/loaders) (for webpack) to process other kinds of assets, like stylesheets, fonts or SVGs. This step transforms the original file, mainly for performance or caching purposes (such as stylesheet minification or browser cache invalidation).

By convention, Nuxt uses the [`assets/`](/docs/4.x/guide/directory-structure/assets) directory to store these files but there is no auto-scan functionality for this directory, and you can use any other name for it.

In your application's code, you can reference a file located in the [`assets/`](/docs/4.x/guide/directory-structure/assets) directory by using the `~/assets/` path.

### Example

For example, referencing an image file that will be processed if a build tool is configured to handle this file extension:

```vue [app.vue]
<template>
  <img src="~/assets/img/nuxt.png" alt="Discover Nuxt" />
</template>
```

<note>

Nuxt won't serve files in the [`assets/`](/docs/4.x/guide/directory-structure/assets) directory at a static URL like `/assets/my-file.png`. If you need a static URL, use the [`public/`](#public-directory) directory.

</note>


# Configuration

> Nuxt is configured with sensible defaults to make you productive.

By default, Nuxt is configured to cover most use cases. The [`nuxt.config.ts`](/docs/4.x/guide/directory-structure/nuxt-config) file can override or extend this default configuration.

## Nuxt Configuration

The [`nuxt.config.ts`](/docs/4.x/guide/directory-structure/nuxt-config) file is located at the root of a Nuxt project and can override or extend the application's behavior.

A minimal configuration file exports the `defineNuxtConfig` function containing an object with your configuration. The `defineNuxtConfig` helper is globally available without import.

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  // My Nuxt config
})
```

This file will often be mentioned in the documentation, for example to add custom scripts, register modules or change rendering modes.

<read-more to="/docs/api/configuration/nuxt-config">

Every option is described in the **Configuration Reference**.

</read-more>

<note>

You don't have to use TypeScript to build an application with Nuxt. However, it is strongly recommended to use the `.ts` extension for the `nuxt.config` file. This way you can benefit from hints in your IDE to avoid typos and mistakes while editing your configuration.

</note>

### Environment Overrides

You can configure fully typed, per-environment overrides in your nuxt.config

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  $production: {
    routeRules: {
      '/**': { isr: true }
    }
  },
  $development: {
    //
  },
  $env: {
    staging: {
      // 
    }
  },
})
```

To select an environment when running a Nuxt CLI command, simply pass the name to the `--envName` flag, like so: `nuxt build --envName staging`.

To learn more about the mechanism behind these overrides, please refer to the `c12` documentation on [environment-specific configuration](https://github.com/unjs/c12?tab=readme-ov-file#environment-specific-configuration).

<video-accordion title="Watch a video from Alexander Lichter about the env-aware nuxt.config.ts" video-id="DFZI2iVCrNc">



</video-accordion>

<note>

If you're authoring layers, you can also use the `$meta` key to provide metadata that you or the consumers of your layer might use.

</note>

### Environment Variables and Private Tokens

The `runtimeConfig` API exposes values like environment variables to the rest of your application. By default, these keys are only available server-side. The keys within `runtimeConfig.public` and `runtimeConfig.app` (which is used by Nuxt internally) are also available client-side.

Those values should be defined in `nuxt.config` and can be overridden using environment variables.

<code-group>

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  runtimeConfig: {
    // The private keys which are only available server-side
    apiSecret: '123',
    // Keys within public are also exposed client-side
    public: {
      apiBase: '/api'
    }
  }
})
```

```ini [.env]
# This will override the value of apiSecret
NUXT_API_SECRET=api_secret_token
```

</code-group>

These variables are exposed to the rest of your application using the [`useRuntimeConfig()`](/docs/4.x/api/composables/use-runtime-config) composable.

```vue [pages/index.vue]
<script setup lang="ts">
const runtimeConfig = useRuntimeConfig()
</script>
```

<read-more to="/docs/guide/going-further/runtime-config">



</read-more>

## App Configuration

The `app.config.ts` file, located in the source directory (by default the root of the project), is used to expose public variables that can be determined at build time. Contrary to the `runtimeConfig` option, these cannot be overridden using environment variables.

A minimal configuration file exports the `defineAppConfig` function containing an object with your configuration. The `defineAppConfig` helper is globally available without import.

```ts [app.config.ts]
export default defineAppConfig({
  title: 'Hello Nuxt',
  theme: {
    dark: true,
    colors: {
      primary: '#ff0000'
    }
  }
})
```

These variables are exposed to the rest of your application using the [`useAppConfig`](/docs/4.x/api/composables/use-app-config) composable.

```vue [pages/index.vue]
<script setup lang="ts">
const appConfig = useAppConfig()
</script>
```

<read-more to="/docs/guide/directory-structure/app-config">



</read-more>

## `runtimeConfig` vs. `app.config`

As stated above, `runtimeConfig` and `app.config` are both used to expose variables to the rest of your application. To determine whether you should use one or the other, here are some guidelines:

- `runtimeConfig`: Private or public tokens that need to be specified after build using environment variables.
- `app.config`: Public tokens that are determined at build time, website configuration such as theme variant, title and any project config that are not sensitive.

<table>
<thead>
  <tr>
    <th>
      Feature
    </th>
    
    <th>
      <code>
        runtimeConfig
      </code>
    </th>
    
    <th>
      <code>
        app.config
      </code>
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      Client Side
    </td>
    
    <td>
      Hydrated
    </td>
    
    <td>
      Bundled
    </td>
  </tr>
  
  <tr>
    <td>
      Environment Variables
    </td>
    
    <td>
      ✅ Yes
    </td>
    
    <td>
      ❌ No
    </td>
  </tr>
  
  <tr>
    <td>
      Reactive
    </td>
    
    <td>
      ✅ Yes
    </td>
    
    <td>
      ✅ Yes
    </td>
  </tr>
  
  <tr>
    <td>
      Types support
    </td>
    
    <td>
      ✅ Partial
    </td>
    
    <td>
      ✅ Yes
    </td>
  </tr>
  
  <tr>
    <td>
      Configuration per Request
    </td>
    
    <td>
      ❌ No
    </td>
    
    <td>
      ✅ Yes
    </td>
  </tr>
  
  <tr>
    <td>
      Hot Module Replacement
    </td>
    
    <td>
      ❌ No
    </td>
    
    <td>
      ✅ Yes
    </td>
  </tr>
  
  <tr>
    <td>
      Non primitive JS types
    </td>
    
    <td>
      ❌ No
    </td>
    
    <td>
      ✅ Yes
    </td>
  </tr>
</tbody>
</table>

## External Configuration Files

Nuxt uses [`nuxt.config.ts`](/docs/4.x/guide/directory-structure/nuxt-config) file as the single source of truth for configurations and skips reading external configuration files. During the course of building your project, you may have a need to configure those. The following table highlights common configurations and, where applicable, how they can be configured with Nuxt.

<table>
<thead>
  <tr>
    <th>
      Name
    </th>
    
    <th>
      Config File
    </th>
    
    <th>
      How To Configure
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      <a href="https://nitro.build" rel="nofollow">
        Nitro
      </a>
    </td>
    
    <td>
      <del>
        <code>
          nitro.config.ts
        </code>
      </del>
    </td>
    
    <td>
      Use <a href="/docs/4.x/api/nuxt-config#nitro">
        <code>
          nitro
        </code>
      </a>
      
       key in <code>
        nuxt.config
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://postcss.org" rel="nofollow">
        PostCSS
      </a>
    </td>
    
    <td>
      <del>
        <code>
          postcss.config.js
        </code>
      </del>
    </td>
    
    <td>
      Use <a href="/docs/4.x/api/nuxt-config#postcss">
        <code>
          postcss
        </code>
      </a>
      
       key in <code>
        nuxt.config
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://vite.dev" rel="nofollow">
        Vite
      </a>
    </td>
    
    <td>
      <del>
        <code>
          vite.config.ts
        </code>
      </del>
    </td>
    
    <td>
      Use <a href="/docs/4.x/api/nuxt-config#vite">
        <code>
          vite
        </code>
      </a>
      
       key in <code>
        nuxt.config
      </code>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://webpack.js.org" rel="nofollow">
        webpack
      </a>
    </td>
    
    <td>
      <del>
        <code>
          webpack.config.ts
        </code>
      </del>
    </td>
    
    <td>
      Use <a href="/docs/4.x/api/nuxt-config#webpack-1">
        <code>
          webpack
        </code>
      </a>
      
       key in <code>
        nuxt.config
      </code>
    </td>
  </tr>
</tbody>
</table>

Here is a list of other common config files:

<table>
<thead>
  <tr>
    <th>
      Name
    </th>
    
    <th>
      Config File
    </th>
    
    <th>
      How To Configure
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      <a href="https://www.typescriptlang.org" rel="nofollow">
        TypeScript
      </a>
    </td>
    
    <td>
      <code>
        tsconfig.json
      </code>
    </td>
    
    <td>
      <a href="/docs/4.x/guide/concepts/typescript#nuxttsconfigjson">
        More Info
      </a>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://eslint.org" rel="nofollow">
        ESLint
      </a>
    </td>
    
    <td>
      <code>
        eslint.config.js
      </code>
    </td>
    
    <td>
      <a href="https://eslint.org/docs/latest/use/configure/configuration-files" rel="nofollow">
        More Info
      </a>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://prettier.io" rel="nofollow">
        Prettier
      </a>
    </td>
    
    <td>
      <code>
        prettier.config.js
      </code>
    </td>
    
    <td>
      <a href="https://prettier.io/docs/en/configuration.html" rel="nofollow">
        More Info
      </a>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://stylelint.io" rel="nofollow">
        Stylelint
      </a>
    </td>
    
    <td>
      <code>
        stylelint.config.js
      </code>
    </td>
    
    <td>
      <a href="https://stylelint.io/user-guide/configure" rel="nofollow">
        More Info
      </a>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://tailwindcss.com" rel="nofollow">
        TailwindCSS
      </a>
    </td>
    
    <td>
      <code>
        tailwind.config.js
      </code>
    </td>
    
    <td>
      <a href="https://tailwindcss.nuxtjs.org/tailwindcss/configuration" rel="nofollow">
        More Info
      </a>
    </td>
  </tr>
  
  <tr>
    <td>
      <a href="https://vitest.dev" rel="nofollow">
        Vitest
      </a>
    </td>
    
    <td>
      <code>
        vitest.config.ts
      </code>
    </td>
    
    <td>
      <a href="https://vitest.dev/config/" rel="nofollow">
        More Info
      </a>
    </td>
  </tr>
</tbody>
</table>

## Vue Configuration

### With Vite

If you need to pass options to `@vitejs/plugin-vue` or `@vitejs/plugin-vue-jsx`, you can do this in your `nuxt.config` file.

- `vite.vue` for `@vitejs/plugin-vue`. Check [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue).
- `vite.vueJsx` for `@vitejs/plugin-vue-jsx`. Check [available options](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx).

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  vite: {
    vue: {
      customElement: true
    },
    vueJsx: {
      mergeProps: true
    }
  }
})
```

<read-more to="/docs/api/configuration/nuxt-config#vue">



</read-more>

### With webpack

If you use webpack and need to configure `vue-loader`, you can do this using `webpack.loaders.vue` key inside your `nuxt.config` file. The available options are [defined here](https://github.com/vuejs/vue-loader/blob/main/src/index.ts#L32-L62).

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  webpack: {
    loaders: {
      vue: {
        hotReload: true,
      }
    }
  }
})
```

<read-more to="/docs/api/configuration/nuxt-config#loaders">



</read-more>

### Enabling Experimental Vue Features

You may need to enable experimental features in Vue, such as `propsDestructure`. Nuxt provides an easy way to do that in `nuxt.config.ts`, no matter which builder you are using:

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  vue: {
    propsDestructure: true
  }
})
```

#### experimental `reactivityTransform` migration from Vue 3.4 and Nuxt 3.9

Since Nuxt 3.9 and Vue 3.4, `reactivityTransform` has been moved from Vue to Vue Macros which has a [Nuxt integration](https://vue-macros.dev/guide/nuxt-integration.html).

<read-more to="/docs/api/configuration/nuxt-config#vue-1">



</read-more>

# Data Fetching

> Nuxt provides composables to handle data fetching within your application.

Nuxt comes with two composables and a built-in library to perform data-fetching in browser or server environments: `useFetch`, [`useAsyncData`](/docs/4.x/api/composables/use-async-data) and `$fetch`.

In a nutshell:

- [`$fetch`](/docs/4.x/api/utils/dollarfetch) is the simplest way to make a network request.
- [`useFetch`](/docs/4.x/api/composables/use-fetch) is a wrapper around `$fetch` that fetches data only once in [universal rendering](/docs/4.x/guide/concepts/rendering#universal-rendering).
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) is similar to `useFetch` but offers more fine-grained control.

Both `useFetch` and `useAsyncData` share a common set of options and patterns that we will detail in the last sections.

## The need for `useFetch` and `useAsyncData`

Nuxt is a framework which can run isomorphic (or universal) code in both server and client environments. If the [`$fetch` function](/docs/4.x/api/utils/dollarfetch) is used to perform data fetching in the setup function of a Vue component, this may cause data to be fetched twice, once on the server (to render the HTML) and once again on the client (when the HTML is hydrated). This can cause hydration issues, increase the time to interactivity and cause unpredictable behavior.

The [`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useAsyncData`](/docs/4.x/api/composables/use-async-data) composables solve this problem by ensuring that if an API call is made on the server, the data is forwarded to the client in the payload.

The payload is a JavaScript object accessible through [`useNuxtApp().payload`](/docs/4.x/api/composables/use-nuxt-app#payload). It is used on the client to avoid refetching the same data when the code is executed in the browser [during hydration](/docs/4.x/guide/concepts/rendering#universal-rendering).

<tip>

Use the [Nuxt DevTools](https://devtools.nuxt.com) to inspect this data in the **Payload tab**.

</tip>

```vue [app.vue]
<script setup lang="ts">
const { data } = await useFetch('/api/data')

async function handleFormSubmit() {
  const res = await $fetch('/api/submit', {
    method: 'POST',
    body: {
      // My form data
    }
  })
}
</script>

<template>
  <div v-if="data == undefined">
    No data
  </div>
  <div v-else>
    <form @submit="handleFormSubmit">
      <!-- form input tags -->
    </form>
  </div>
</template>
```

In the example above, `useFetch` would make sure that the request would occur in the server and is properly forwarded to the browser. `$fetch` has no such mechanism and is a better option to use when the request is solely made from the browser.

### Suspense

Nuxt uses Vue's [`<Suspense>`](https://vuejs.org/guide/built-ins/suspense) component under the hood to prevent navigation before every async data is available to the view. The data fetching composables can help you leverage this feature and use what suits best on a per-call basis.

<note>

You can add the [`<NuxtLoadingIndicator>`](/docs/4.x/api/components/nuxt-loading-indicator) to add a progress bar between page navigations.

</note>

## `$fetch`

Nuxt includes the [ofetch](https://github.com/unjs/ofetch) library, and is auto-imported as the `$fetch` alias globally across your application.

```vue [pages/todos.vue]twoslash
<script setup lang="ts">
async function addTodo() {
  const todo = await $fetch('/api/todos', {
    method: 'POST',
    body: {
      // My todo data
    }
  })
}
</script>
```

<warning>

Beware that using only `$fetch` will not provide [network calls de-duplication and navigation prevention](#the-need-for-usefetch-and-useasyncdata). <br />


It is recommended to use `$fetch` for client-side interactions (event-based) or combined with [`useAsyncData`](#useasyncdata) when fetching the initial component data.

</warning>

<read-more to="/docs/api/utils/dollarfetch">

Read more about `$fetch`.

</read-more>

### Pass Client Headers to the API

When calling `useFetch` on the server, Nuxt will use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy client headers and cookies (with the exception of headers not meant to be forwarded, like `host`).

```vue
<script setup lang="ts">
const { data } = await useFetch('/api/echo');
</script>
```

```ts
// /api/echo.ts
export default defineEventHandler(event => parseCookies(event))
```

Alternatively, the example below shows how to use [`useRequestHeaders`](/docs/4.x/api/composables/use-request-headers) to access and send cookies to the API from a server-side request (originating on the client). Using an isomorphic `$fetch` call, we ensure that the API endpoint has access to the same `cookie` header originally sent by the user's browser. This is only necessary if you aren't using `useFetch`.

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])

async function getCurrentUser() {
  return await $fetch('/api/me', { headers })
}
</script>
```

<tip>

You can also use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy headers to the call automatically.

</tip>

<caution>

Be very careful before proxying headers to an external API and just include headers that you need. Not all headers are safe to be bypassed and might introduce unwanted behavior. Here is a list of common headers that are NOT to be proxied:

- `host`, `accept`
- `content-length`, `content-md5`, `content-type`
- `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
- `cf-connecting-ip`, `cf-ray`

</caution>

## `useFetch`

The [`useFetch`](/docs/4.x/api/composables/use-fetch) composable uses `$fetch` under-the-hood to make SSR-safe network calls in the setup function.

```vue [app.vue]twoslash
<script setup lang="ts">
const { data: count } = await useFetch('/api/count')
</script>

<template>
  <p>Page visits: {{ count }}</p>
</template>
```

This composable is a wrapper around the [`useAsyncData`](/docs/4.x/api/composables/use-async-data) composable and `$fetch` utility.

<video-accordion title="Watch a video from Alexander Lichter to avoid using useFetch the wrong way" video-id="njsGVmcWviY">



</video-accordion>

<read-more to="/docs/api/composables/use-fetch">



</read-more>

<link-example to="/docs/examples/features/data-fetching">



</link-example>

## `useAsyncData`

The `useAsyncData` composable is responsible for wrapping async logic and returning the result once it is resolved.

<tip>

`useFetch(url)` is nearly equivalent to `useAsyncData(url, () => event.$fetch(url))`. <br />


It's developer experience sugar for the most common use case. (You can find out more about `event.fetch` at [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch).)

</tip>

<video-accordion title="Watch a video from Alexander Lichter to dig deeper into the difference between useFetch and useAsyncData" video-id="0X-aOpSGabA">



</video-accordion>

There are some cases when using the [`useFetch`](/docs/4.x/api/composables/use-fetch) composable is not appropriate, for example when a CMS or a third-party provide their own query layer. In this case, you can use [`useAsyncData`](/docs/4.x/api/composables/use-async-data) to wrap your calls and still keep the benefits provided by the composable.

```vue [pages/users.vue]
<script setup lang="ts">
const { data, error } = await useAsyncData('users', () => myGetFunction('users'))

// This is also possible:
const { data, error } = await useAsyncData(() => myGetFunction('users'))
</script>
```

<note>

The first argument of [`useAsyncData`](/docs/4.x/api/composables/use-async-data) is a unique key used to cache the response of the second argument, the querying function. This key can be ignored by directly passing the querying function, the key will be auto-generated.
<br />

 <br />


Since the autogenerated key only takes into account the file and line where `useAsyncData` is invoked, it is recommended to always create your own key to avoid unwanted behavior, like when you are creating your own custom composable wrapping `useAsyncData`.
<br />

 <br />


Setting a key can be useful to share the same data between components using [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data) or to [refresh specific data](/docs/4.x/api/utils/refresh-nuxt-data#refresh-specific-data).

</note>

```vue [pages/users/[id].vue]
<script setup lang="ts">
const { id } = useRoute().params

const { data, error } = await useAsyncData(`user:${id}`, () => {
  return myGetFunction('users', { id })
})
</script>
```

The `useAsyncData` composable is a great way to wrap and wait for multiple `$fetch` requests to be completed, and then process the results.

```vue
<script setup lang="ts">
const { data: discounts, status } = await useAsyncData('cart-discount', async () => {
  const [coupons, offers] = await Promise.all([
    $fetch('/cart/coupons'),
    $fetch('/cart/offers')
  ])

  return { coupons, offers }
})
// discounts.value.coupons
// discounts.value.offers
</script>
```

<note>

`useAsyncData` is for fetching and caching data, not triggering side effects like calling Pinia actions, as this can cause unintended behavior such as repeated executions with nullish values. If you need to trigger side effects, use the [`callOnce`](/docs/4.x/api/utils/call-once) utility to do so.

```vue
<script setup lang="ts">
const offersStore = useOffersStore()

// you can't do this
await useAsyncData(() => offersStore.getOffer(route.params.slug))
</script>
```

</note>

<read-more to="/docs/api/composables/use-async-data">

Read more about `useAsyncData`.

</read-more>

## Return Values

`useFetch` and `useAsyncData` have the same return values listed below.

- `data`: the result of the asynchronous function that is passed in.
- `refresh`/`execute`: a function that can be used to refresh the data returned by the `handler` function.
- `clear`: a function that can be used to set `data` to `undefined` (or the value of `options.default()` if provided), set `error` to `undefined`, set `status` to `idle`, and mark any currently pending requests as cancelled.
- `error`: an error object if the data fetching failed.
- `status`: a string indicating the status of the data request (`"idle"`, `"pending"`, `"success"`, `"error"`).

<note>

`data`, `error` and `status` are Vue refs accessible with `.value` in `<script setup>`

</note>

By default, Nuxt waits until a `refresh` is finished before it can be executed again.

<note>

If you have not fetched data on the server (for example, with `server: false`), then the data *will not* be fetched until hydration completes. This means even if you await `useFetch` on client-side, `data` will remain null within `<script setup>`.

</note>

## Options

[`useAsyncData`](/docs/4.x/api/composables/use-async-data) and [`useFetch`](/docs/4.x/api/composables/use-fetch) return the same object type and accept a common set of options as their last argument. They can help you control the composables behavior, such as navigation blocking, caching or execution.

### Lazy

By default, data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue's Suspense. This feature can be ignored on client-side navigation with the `lazy` option. In that case, you will have to manually handle loading state using the `status` value.

```vue [app.vue]twoslash
<script setup lang="ts">
const { status, data: posts } = useFetch('/api/posts', {
  lazy: true
})
</script>

<template>
  <!-- you will need to handle a loading state -->
  <div v-if="status === 'pending'">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- do something -->
    </div>
  </div>
</template>
```

You can alternatively use [`useLazyFetch`](/docs/4.x/api/composables/use-lazy-fetch) and `useLazyAsyncData` as convenient methods to perform the same.

```vuetwoslash
<script setup lang="ts">
const { status, data: posts } = useLazyFetch('/api/posts')
</script>
```

<read-more to="/docs/api/composables/use-lazy-fetch">

Read more about `useLazyFetch`.

</read-more>

<read-more to="/docs/api/composables/use-lazy-async-data">

Read more about `useLazyAsyncData`.

</read-more>

<video-accordion title="Watch a video from Vue School on blocking vs. non-blocking (lazy) requests" video-id="1022000555" platform="vimeo">



</video-accordion>

### Client-only fetching

By default, data fetching composables will perform their asynchronous function on both client and server environments. Set the `server` option to `false` to only perform the call on the client-side. On initial load, the data will not be fetched before hydration is complete so you have to handle a pending state, though on subsequent client-side navigation the data will be awaited before loading the page.

Combined with the `lazy` option, this can be useful for data that is not needed on the first render (for example, non-SEO sensitive data).

```tstwoslash
/* This call is performed before hydration */
const articles = await useFetch('/api/article')

/* This call will only be performed on the client */
const { status, data: comments } = useFetch('/api/comments', {
  lazy: true,
  server: false
})
```

The `useFetch` composable is meant to be invoked in setup method or called directly at the top level of a function in lifecycle hooks, otherwise you should use [`$fetch` method](#fetch).

### Minimize payload size

The `pick` option helps you to minimize the payload size stored in your HTML document by only selecting the fields that you want returned from the composables.

```vue
<script setup lang="ts">
/* only pick the fields used in your template */
const { data: mountain } = await useFetch('/api/mountains/everest', {
  pick: ['title', 'description']
})
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

If you need more control or map over several objects, you can use the `transform` function to alter the result of the query.

```ts
const { data: mountains } = await useFetch('/api/mountains', {
  transform: (mountains) => {
    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))
  }
})
```

<note>

Both `pick` and `transform` don't prevent the unwanted data from being fetched initially. But they will prevent unwanted data from being added to the payload transferred from server to client.

</note>

<video-accordion title="Watch a video from Vue School on minimizing payload size" video-id="1026410430" platform="vimeo">



</video-accordion>

### Caching and refetching

#### Keys

[`useFetch`](/docs/4.x/api/composables/use-fetch) and [`useAsyncData`](/docs/4.x/api/composables/use-async-data) use keys to prevent refetching the same data.

- [`useFetch`](/docs/4.x/api/composables/use-fetch) uses the provided URL as a key. Alternatively, a `key` value can be provided in the `options` object passed as a last argument.
- [`useAsyncData`](/docs/4.x/api/composables/use-async-data) uses its first argument as a key if it is a string. If the first argument is the handler function that performs the query, then a key that is unique to the file name and line number of the instance of `useAsyncData` will be generated for you.

<tip>

To get the cached data by key, you can use [`useNuxtData`](/docs/4.x/api/composables/use-nuxt-data)

</tip>

<video-accordion title="Watch a video from Vue School on caching data with the key option" video-id="1026410044" platform="vimeo">



</video-accordion>

#### Shared State and Option Consistency

When multiple components use the same key with `useAsyncData` or `useFetch`, they will share the same `data`, `error` and `status` refs. This ensures consistency across components but requires some options to be consistent.

The following options **must be consistent** across all calls with the same key:

- `handler` function
- `deep` option
- `transform` function
- `pick` array
- `getCachedData` function
- `default` value

```ts
// ❌ This will trigger a development warning
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { deep: false })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { deep: true })
```

The following options **can safely differ** without triggering warnings:

- `server`
- `lazy`
- `immediate`
- `dedupe`
- `watch`

```ts
// ✅ This is allowed
const { data: users1 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: true })
const { data: users2 } = useAsyncData('users', () => $fetch('/api/users'), { immediate: false })
```

If you need independent instances, use different keys:

```ts
// These are completely independent instances
const { data: users1 } = useAsyncData('users-1', () => $fetch('/api/users'))
const { data: users2 } = useAsyncData('users-2', () => $fetch('/api/users'))
```

#### Reactive Keys

You can use computed refs, plain refs or getter functions as keys, allowing for dynamic data fetching that automatically updates when dependencies change:

```ts
// Using a computed property as a key
const userId = ref('123')
const { data: user } = useAsyncData(
  computed(() => `user-${userId.value}`),
  () => fetchUser(userId.value)
)

// When userId changes, the data will be automatically refetched
// and the old data will be cleaned up if no other components use it
userId.value = '456'
```

#### Refresh and execute

If you want to fetch or refresh data manually, use the `execute` or `refresh` function provided by the composables.

```vuetwoslash
<script setup lang="ts">
const { data, error, execute, refresh } = await useFetch('/api/users')
</script>

<template>
  <div>
    <p>{{ data }}</p>
    <button @click="() => refresh()">Refresh data</button>
  </div>
</template>
```

The `execute` function is an alias for `refresh` that works in exactly the same way but is more semantic for cases when the fetch is [not immediate](#not-immediate).

<tip>

To globally refetch or invalidate cached data, see [`clearNuxtData`](/docs/4.x/api/utils/clear-nuxt-data) and [`refreshNuxtData`](/docs/4.x/api/utils/refresh-nuxt-data).

</tip>

#### Clear

If you want to clear the data provided, for whatever reason, without needing to know the specific key to pass to `clearNuxtData`, you can use the `clear` function provided by the composables.

```vuetwoslash
<script setup lang="ts">
const { data, clear } = await useFetch('/api/users')

const route = useRoute()
watch(() => route.path, (path) => {
  if (path === '/') clear()
})
</script>
```

#### Watch

To re-run your fetching function each time other reactive values in your application change, use the `watch` option. You can use it for one or multiple *watchable* elements.

```vuetwoslash
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch('/api/users', {
  /* Changing the id will trigger a refetch */
  watch: [id]
})
</script>
```

Note that **watching a reactive value won't change the URL fetched**. For example, this will keep fetching the same initial ID of the user because the URL is constructed at the moment the function is invoked.

```vue
<script setup lang="ts">
const id = ref(1)

const { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {
  watch: [id]
})
</script>
```

If you need to change the URL based on a reactive value, you may want to use a [computed URL](#computed-url) instead.

#### Computed URL

Sometimes you may need to compute a URL from reactive values, and refresh the data each time these change. Instead of juggling your way around, you can attach each param as a reactive value. Nuxt will automatically use the reactive value and re-fetch each time it changes.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch('/api/user', {
  query: {
    user_id: id
  }
})
</script>
```

In the case of more complex URL construction, you may use a callback as a [computed getter](https://vuejs.org/guide/essentials/computed.html) that returns the URL string.

Every time a dependency changes, the data will be fetched using the newly constructed URL. Combine this with [not-immediate](#not-immediate), and you can wait until the reactive element changes before fetching.

```vue
<script setup lang="ts">
const id = ref(null)

const { data, status } = useLazyFetch(() => `/api/users/${id.value}`, {
  immediate: false
})

const pending = computed(() => status.value === 'pending');
</script>

<template>
  <div>
    <!-- disable the input while fetching -->
    <input v-model="id" type="number" :disabled="pending"/>

    <div v-if="status === 'idle'">
      Type an user ID
    </div>

    <div v-else-if="pending">
      Loading ...
    </div>

    <div v-else>
      {{ data }}
    </div>
  </div>
</template>
```

If you need to force a refresh when other reactive values change, you can also [watch other values](#watch).

### Not immediate

The `useFetch` composable will start fetching data the moment is invoked. You may prevent this by setting `immediate: false`, for example, to wait for user interaction.

With that, you will need both the `status` to handle the fetch lifecycle, and `execute` to start the data fetch.

```vue
<script setup lang="ts">
const { data, error, execute, status } = await useLazyFetch('/api/comments', {
  immediate: false
})
</script>

<template>
  <div v-if="status === 'idle'">
    <button @click="execute">Get data</button>
  </div>

  <div v-else-if="status === 'pending'">
    Loading comments...
  </div>

  <div v-else>
    {{ data }}
  </div>
</template>
```

For finer control, the `status` variable can be:

- `idle` when the fetch hasn't started
- `pending` when a fetch has started but not yet completed
- `error` when the fetch fails
- `success` when the fetch is completed successfully

## Passing Headers and Cookies

When we call `$fetch` in the browser, user headers like `cookie` will be directly sent to the API.

Normally, during server-side-rendering, due to security considerations, the `$fetch` wouldn't include the user's browser cookies, nor pass on cookies from the fetch response.

However, when calling `useFetch` with a relative URL on the server, Nuxt will use [`useRequestFetch`](/docs/4.x/api/composables/use-request-fetch) to proxy headers and cookies (with the exception of headers not meant to be forwarded, like `host`).

### Pass Cookies From Server-side API Calls on SSR Response

If you want to pass on/proxy cookies in the other direction, from an internal request back to the client, you will need to handle this yourself.

```ts [composables/fetch.ts]
import { appendResponseHeader } from 'h3'
import type { H3Event } from 'h3'

export const fetchWithCookie = async (event: H3Event, url: string) => {
  /* Get the response from the server endpoint */
  const res = await $fetch.raw(url)
  /* Get the cookies from the response */
  const cookies = res.headers.getSetCookie()
  /* Attach each cookie to our incoming Request */
  for (const cookie of cookies) {
    appendResponseHeader(event, 'set-cookie', cookie)
  }
  /* Return the data of the response */
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()

const { data: result } = await useAsyncData(() => fetchWithCookie(event!, '/api/with-cookie'))

onMounted(() => console.log(document.cookie))
</script>
```

## Options API Support

Nuxt provides a way to perform `asyncData` fetching within the Options API. You must wrap your component definition within `defineNuxtComponent` for this to work.

```vue
<script>
export default defineNuxtComponent({
  /* Use the fetchKey option to provide a unique key */
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

<note>

Using `<script setup>` or `<script setup lang="ts">` are the recommended way of declaring Vue components in Nuxt.

</note>

<read-more to="/docs/api/utils/define-nuxt-component">



</read-more>

## Serializing Data From Server to Client

When using `useAsyncData` and `useLazyAsyncData` to transfer data fetched on server to the client (as well as anything else that utilizes [the Nuxt payload](/docs/4.x/api/composables/use-nuxt-app#payload)), the payload is serialized with [`devalue`](https://github.com/Rich-Harris/devalue). This allows us to transfer not just basic JSON but also to serialize and revive/deserialize more advanced kinds of data, such as regular expressions, Dates, Map and Set, `ref`, `reactive`, `shallowRef`, `shallowReactive` and `NuxtError` - and more.

It is also possible to define your own serializer/deserializer for types that are not supported by Nuxt. You can read more in the [`useNuxtApp`](/docs/4.x/api/composables/use-nuxt-app#payload) docs.

<note>

Note that this *does not apply* to data passed from your server routes when fetched with `$fetch` or `useFetch` - see the next section for more information.

</note>

## Serializing Data From API Routes

When fetching data from the `server` directory, the response is serialized using `JSON.stringify`. However, since serialization is limited to only JavaScript primitive types, Nuxt does its best to convert the return type of `$fetch` and [`useFetch`](/docs/4.x/api/composables/use-fetch) to match the actual value.

<read-more to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" icon="i-simple-icons-mdnwebdocs" target="_blank">

Learn more about `JSON.stringify` limitations.

</read-more>

### Example

```ts [server/api/foo.ts]
export default defineEventHandler(() => {
  return new Date()
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as string even though we returned a Date object
const { data } = await useFetch('/api/foo')
</script>
```

### Custom serializer function

To customize the serialization behavior, you can define a `toJSON` function on your returned object. If you define a `toJSON` method, Nuxt will respect the return type of the function and will not try to convert the types.

```ts [server/api/bar.ts]
export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    toJSON() {
      return {
        createdAt: {
          year: this.createdAt.getFullYear(),
          month: this.createdAt.getMonth(),
          day: this.createdAt.getDate(),
        },
      }
    },
  }
  return data
})
```

```vue [app.vue]
<script setup lang="ts">
// Type of `data` is inferred as
// {
//   createdAt: {
//     year: number
//     month: number
//     day: number
//   }
// }
const { data } = await useFetch('/api/bar')
</script>
```

### Using an alternative serializer

Nuxt does not currently support an alternative serializer to `JSON.stringify`. However, you can return your payload as a normal string and utilize the `toJSON` method to maintain type safety.

In the example below, we use [superjson](https://github.com/blitz-js/superjson) as our serializer.

```ts [server/api/superjson.ts]
import superjson from 'superjson'

export default defineEventHandler(() => {
  const data = {
    createdAt: new Date(),

    // Workaround the type conversion
    toJSON() {
      return this
    }
  }

  // Serialize the output to string, using superjson
  return superjson.stringify(data) as unknown as typeof data
})
```

```vue [app.vue]
<script setup lang="ts">
import superjson from 'superjson'

// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods
const { data } = await useFetch('/api/superjson', {
  transform: (value) => {
    return superjson.parse(value as unknown as string)
  },
})
</script>
```

## Recipes

### Consuming SSE (Server-Sent Events) via POST request

<tip>

If you're consuming SSE via GET request, you can use [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) or VueUse composable [`useEventSource`](https://vueuse.org/core/useEventSource/).

</tip>

When consuming SSE via POST request, you need to handle the connection manually. Here's how you can do it:

```ts
// Make a POST request to the SSE endpoint
const response = await $fetch<ReadableStream>('/chats/ask-ai', {
  method: 'POST',
  body: {
    query: "Hello AI, how are you?",
  },
  responseType: 'stream',
})

// Create a new ReadableStream from the response with TextDecoderStream to get the data as text
const reader = response.pipeThrough(new TextDecoderStream()).getReader()

// Read the chunk of data as we get it
while (true) {
  const { value, done } = await reader.read()

  if (done)
    break

  console.log('Received:', value)
}
```

### Making parallel requests

When requests don't rely on each other, you can make them in parallel with `Promise.all()` to boost performance.

```ts
const { data } = await useAsyncData(() => {
  return Promise.all([
    $fetch("/api/comments/"), 
    $fetch("/api/author/12")
  ]);
});

const comments = computed(() => data.value?.[0]);
const author = computed(() => data.value?.[1]);
```

<video-accordion title="Watch a video from Vue School on parallel data fetching" video-id="1024262536" platform="vimeo">



</video-accordion>

# State Management

> Nuxt provides powerful state management libraries and the useState composable to create a reactive and SSR-friendly shared state.

Nuxt provides the [`useState`](/docs/4.x/api/composables/use-state) composable to create a reactive and SSR-friendly shared state across components.

[`useState`](/docs/4.x/api/composables/use-state) is an SSR-friendly [`ref`](https://vuejs.org/api/reactivity-core.html#ref) replacement. Its value will be preserved after server-side rendering (during client-side hydration) and shared across all components using a unique key.

<video-accordion title="Watch a video from Alexander Lichter about why and when to use useState" video-id="mv0WcBABcIk">



</video-accordion>

<important>

Because the data inside [`useState`](/docs/4.x/api/composables/use-state) will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.

</important>

<read-more to="/docs/api/composables/use-state">

Read more about `useState` composable.

</read-more>

## Best Practices

<warning>

Never define `const state = ref()` outside of `<script setup>` or `setup()` function.<br />


For example, doing `export myState = ref({})` would result in state shared across requests on the server and can lead to memory leaks.

</warning>

<tip icon="i-lucide-circle-check">

Instead use `const useX = () => useState('x')`

</tip>

## Examples

### Basic Usage

In this example, we use a component-local counter state. Any other component that uses `useState('counter')` shares the same reactive state.

```vue [app.vue]twoslash
<script setup lang="ts">
const counter = useState('counter', () => Math.round(Math.random() * 1000))
</script>

<template>
  <div>
    Counter: {{ counter }}
    <button @click="counter++">
      +
    </button>
    <button @click="counter--">
      -
    </button>
  </div>
</template>
```

<link-example to="/docs/examples/features/state-management">



</link-example>

<note>

To globally invalidate cached state, see [`clearNuxtState`](/docs/4.x/api/utils/clear-nuxt-state) util.

</note>

### Initializing State

Most of the time, you will want to initialize your state with data that resolves asynchronously. You can use the [`app.vue`](/docs/4.x/guide/directory-structure/app) component with the [`callOnce`](/docs/4.x/api/utils/call-once) util to do so.

```vue [app.vue]twoslash
<script setup lang="ts">
const websiteConfig = useState('config')

await callOnce(async () => {
  websiteConfig.value = await $fetch('https://my-cms.com/api/website-config')
})
</script>
```

<tip>

This is similar to the [`nuxtServerInit` action](https://v2.nuxt.com/docs/directory-structure/store/#the-nuxtserverinit-action) in Nuxt 2, which allows filling the initial state of your store server-side before rendering the page.

</tip>

<read-more to="/docs/api/utils/call-once">



</read-more>

### Usage with Pinia

In this example, we leverage the [Pinia module](/modules/pinia) to create a global store and use it across the app.

<important>

Make sure to install the Pinia module with `npx nuxt module add pinia` or follow the [module's installation steps](https://pinia.vuejs.org/ssr/nuxt.html#Installation).

</important>

<code-group>

```ts [stores/website.ts]
export const useWebsiteStore = defineStore('websiteStore', {
  state: () => ({
    name: '',
    description: ''
  }),
  actions: {
    async fetch() {
      const infos = await $fetch('https://api.nuxt.com/modules/pinia')

      this.name = infos.name
      this.description = infos.description
    }
  }
})
```

```vue [app.vue]
<script setup lang="ts">
const website = useWebsiteStore()

await callOnce(website.fetch)
</script>

<template>
  <main>
    <h1>{{ website.name }}</h1>
    <p>{{ website.description }}</p>
  </main>
</template>
```

</code-group>

## Advanced Usage

<code-group>

```ts [composables/locale.ts]
import type { Ref } from 'vue'

export const useLocale = () => {
  return useState<string>('locale', () => useDefaultLocale().value)
}

export const useDefaultLocale = (fallback = 'en-US') => {
  const locale = ref(fallback)
  if (import.meta.server) {
    const reqLocale = useRequestHeaders()['accept-language']?.split(',')[0]
    if (reqLocale) {
      locale.value = reqLocale
    }
  } else if (import.meta.client) {
    const navLang = navigator.language
    if (navLang) {
      locale.value = navLang
    }
  }
  return locale
}

export const useLocales = () => {
  const locale = useLocale()
  const locales = ref([
    'en-US',
    'en-GB',
    ...
    'ja-JP-u-ca-japanese'
  ])
  if (!locales.value.includes(locale.value)) {
    locales.value.unshift(locale.value)
  }
  return locales
}

export const useLocaleDate = (date: Ref<Date> | Date, locale = useLocale()) => {
  return computed(() => new Intl.DateTimeFormat(locale.value, { dateStyle: 'full' }).format(unref(date)))
}
```

```vue [app.vue]
<script setup lang="ts">
const locales = useLocales()
const locale = useLocale()
const date = useLocaleDate(new Date('2016-10-26'))
</script>

<template>
  <div>
    <h1>Nuxt birthday</h1>
    <p>{{ date }}</p>
    <label for="locale-chooser">Preview a different locale</label>
    <select id="locale-chooser" v-model="locale">
      <option v-for="locale of locales" :key="locale" :value="locale">
        {{ locale }}
      </option>
    </select>
  </div>
</template>
```

</code-group>

<link-example to="/docs/examples/advanced/locale">



</link-example>

## Shared State

By using [auto-imported composables](/docs/4.x/guide/directory-structure/composables) we can define global type-safe states and import them across the app.

```ts [composables/states.ts]twoslash
export const useColor = () => useState<string>('color', () => 'pink')
```

```vue [app.vue]
<script setup lang="ts">
// ---cut-start---
const useColor = () => useState<string>('color', () => 'pink')
// ---cut-end---
const color = useColor() // Same as useState('color')
</script>

<template>
  <p>Current color: {{ color }}</p>
</template>
```

<video-accordion title="Watch a video from Daniel Roe on how to deal with global state and SSR in Nuxt" video-id="dZSNW07sO-A">



</video-accordion>

## Using third-party libraries

Nuxt **used to rely** on the Vuex library to provide global state management. If you are migrating from Nuxt 2, please head to [the migration guide](/docs/4.x/migration/configuration#vuex).

Nuxt is not opinionated about state management, so feel free to choose the right solution for your needs. There are multiple integrations with the most popular state management libraries, including:

- [Pinia](/modules/pinia) - the official Vue recommendation <--USE PINIA FOR ALL STATE-->
 

 # Transitions

> Apply transitions between pages and layouts with Vue or native browser View Transitions.

<note>

Nuxt leverages Vue's [`<Transition>`](https://vuejs.org/guide/built-ins/transition.html#the-transition-component) component to apply transitions between pages and layouts.

</note>

## Page Transitions

You can enable page transitions to apply an automatic transition for all your [pages](/docs/4.x/guide/directory-structure/pages).

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: { name: 'page', mode: 'out-in' }
  }
})
```

<note>

If you are changing layouts as well as page, the page transition you set here will not run. Instead, you should set a [layout transition](/docs/4.x/getting-started/transitions#layout-transitions).

</note>

To start adding transition between your pages, add the following CSS to your [`app.vue`](/docs/4.x/guide/directory-structure/app):

<code-group>

```vue [app.vue]
<template>
  <NuxtPage />
</template>

<style>
.page-enter-active,
.page-leave-active {
  transition: all 0.4s;
}
.page-enter-from,
.page-leave-to {
  opacity: 0;
  filter: blur(1rem);
}
</style>
```

```vue [pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [pages/about.vue]
<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```

</code-group>

This produces the following result when navigating between pages:

<video controls="true" className="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665061349/nuxt3/nuxt3-page-transitions_umwvmh.jpg">
<source src="https://res.cloudinary.com/nuxt/video/upload/v1665061349/nuxt3/nuxt3-page-transitions_umwvmh.mp4" type="video/mp4" />
</video>

To set a different transition for a page, set the `pageTransition` key in [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) of the page:

<code-group>

```vue [pages/about.vue]twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'rotate'
  }
})
</script>
```

```vue [app.vue]
<template>
  <NuxtPage />
</template>

<style>
/* ... */
.rotate-enter-active,
.rotate-leave-active {
  transition: all 0.4s;
}
.rotate-enter-from,
.rotate-leave-to {
  opacity: 0;
  transform: rotate3d(1, 1, 1, 15deg);
}
</style>
```

</code-group>

Moving to the about page will add the 3d rotation effect:

<video controls="true" className="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665063233/nuxt3/nuxt3-page-transitions-cutom.jpg">
<source src="https://res.cloudinary.com/nuxt/video/upload/v1665063233/nuxt3/nuxt3-page-transitions-cutom.mp4" type="video/mp4" />
</video>

## Layout Transitions

You can enable layout transitions to apply an automatic transition for all your [layouts](/docs/4.x/guide/directory-structure/layouts).

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    layoutTransition: { name: 'layout', mode: 'out-in' }
  }
})
```

To start adding transition between your pages and layouts, add the following CSS to your [`app.vue`](/docs/4.x/guide/directory-structure/app):

<code-group>

```vue [app.vue]
<template>
  <NuxtLayout>
    <NuxtPage />
  </NuxtLayout>
</template>

<style>
.layout-enter-active,
.layout-leave-active {
  transition: all 0.4s;
}
.layout-enter-from,
.layout-leave-to {
  filter: grayscale(1);
}
</style>
```

```vue [layouts/default.vue]
<template>
  <div>
    <pre>default layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: lightgreen;
}
</style>
```

```vue [layouts/orange.vue]
<template>
  <div>
    <pre>orange layout</pre>
    <slot />
  </div>
</template>

<style scoped>
div {
  background-color: #eebb90;
  padding: 20px;
  height: 100vh;
}
</style>
```

```vue [pages/index.vue]
<template>
  <div>
    <h1>Home page</h1>
    <NuxtLink to="/about">About page</NuxtLink>
  </div>
</template>
```

```vue [pages/about.vue]
<script setup lang="ts">
definePageMeta({
  layout: 'orange'
})
</script>

<template>
  <div>
    <h1>About page</h1>
    <NuxtLink to="/">Home page</NuxtLink>
  </div>
</template>
```

</code-group>

This produces the following result when navigating between pages:

<video controls="true" className="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665065289/nuxt3/nuxt3-layouts-transitions_c9hwlx.jpg">
<source src="https://res.cloudinary.com/nuxt/video/upload/v1665065289/nuxt3/nuxt3-layouts-transitions_c9hwlx.mp4" type="video/mp4" />
</video>

Similar to `pageTransition`, you can apply a custom `layoutTransition` to the page component using `definePageMeta`:

```vue [pages/about.vue]twoslash
<script setup lang="ts">
definePageMeta({
  layout: 'orange',
  layoutTransition: {
    name: 'slide-in'
  }
})
</script>
```

## Global Settings

You can customize these default transition names globally using `nuxt.config`.

Both `pageTransition` and `layoutTransition` keys accept [`TransitionProps`](https://vuejs.org/api/built-in-components.html#transition) as JSON serializable values where you can pass the `name`, `mode` and other valid transition-props of the custom CSS transition.

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: {
      name: 'fade',
      mode: 'out-in' // default
    },
    layoutTransition: {
      name: 'slide',
      mode: 'out-in' // default
    }
  }
})
```

<warning>

If you change the `name` property, you also have to rename the CSS classes accordingly.

</warning>

To override the global transition property, use the `definePageMeta` to define page or layout transitions for a single Nuxt page and override any page or layout transitions that are defined globally in `nuxt.config` file.

```vue [pages/some-page.vue]twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'bounce',
    mode: 'out-in' // default
  }
})
</script>
```

## Disable Transitions

`pageTransition` and `layoutTransition` can be disabled for a specific route:

```vue [pages/some-page.vue]twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: false,
  layoutTransition: false
})
</script>
```

Or globally in the `nuxt.config`:

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    pageTransition: false,
    layoutTransition: false
  }
})
```

## JavaScript Hooks

For advanced use-cases, you can use JavaScript hooks to create highly dynamic and custom transitions for your Nuxt pages.

This way presents perfect use-cases for JavaScript animation libraries such as [GSAP](https://gsap.com).

```vue [pages/some-page.vue]twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'custom-flip',
    mode: 'out-in',
    onBeforeEnter: (el) => {
      console.log('Before enter...')
    },
    onEnter: (el, done) => {},
    onAfterEnter: (el) => {}
  }
})
</script>
```

<tip>

Learn more about additional [JavaScript hooks](https://vuejs.org/guide/built-ins/transition.html#javascript-hooks) available in the `Transition` component.

</tip>

## Dynamic Transitions

To apply dynamic transitions using conditional logic, you can leverage inline [middleware](/docs/4.x/guide/directory-structure/middleware) to assign a different transition name to `to.meta.pageTransition`.

<code-group>

```vue [pages/[id].vue]twoslash
<script setup lang="ts">
definePageMeta({
  pageTransition: {
    name: 'slide-right',
    mode: 'out-in'
  },
  middleware (to, from) {
    if (to.meta.pageTransition && typeof to.meta.pageTransition !== 'boolean')
      to.meta.pageTransition.name = +to.params.id! > +from.params.id! ? 'slide-left' : 'slide-right'
  }
})
</script>

<template>
  <h1>#{{ $route.params.id }}</h1>
</template>

<style>
.slide-left-enter-active,
.slide-left-leave-active,
.slide-right-enter-active,
.slide-right-leave-active {
  transition: all 0.2s;
}
.slide-left-enter-from {
  opacity: 0;
  transform: translate(50px, 0);
}
.slide-left-leave-to {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-enter-from {
  opacity: 0;
  transform: translate(-50px, 0);
}
.slide-right-leave-to {
  opacity: 0;
  transform: translate(50px, 0);
}
</style>
```

```vue [layouts/default.vue]
<script setup lang="ts">
const route = useRoute()
const id = computed(() => Number(route.params.id || 1))
const prev = computed(() => '/' + (id.value - 1))
const next = computed(() => '/' + (id.value + 1))
</script>

<template>
  <div>
    <slot />
    <div v-if="$route.params.id">
      <NuxtLink :to="prev">⬅️</NuxtLink> |
      <NuxtLink :to="next">➡️</NuxtLink>
    </div>
  </div>
</template>
```

</code-group>

The page now applies the `slide-left` transition when going to the next id and `slide-right` for the previous:

<video controls="true" className="rounded" poster="https://res.cloudinary.com/nuxt/video/upload/v1665069410/nuxt3/nuxt-dynamic-page-transitions.jpg">
<source src="https://res.cloudinary.com/nuxt/video/upload/v1665069410/nuxt3/nuxt-dynamic-page-transitions.mp4" type="video/mp4" />
</video>

## Transition with NuxtPage

When `<NuxtPage />` is used in `app.vue`, transitions can be configured with the `transition` prop to activate transitions globally.

```vue [app.vue]
<template>
  <div>
    <NuxtLayout>
      <NuxtPage :transition="{
        name: 'bounce',
        mode: 'out-in'
      }" />
    </NuxtLayout>
  </div>
</template>
```

<note>

Remember, this page transition cannot be overridden with `definePageMeta` on individual pages.

</note>

## View Transitions API (experimental)

Nuxt ships with an experimental implementation of the [**View Transitions API**](https://developer.chrome.com/docs/web-platform/view-transitions) (see [MDN](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API)). This is an exciting new way to implement native browser transitions which (among other things) have the ability to transition between unrelated elements on different pages.

You can check a demo on [https://nuxt-view-transitions.surge.sh](https://nuxt-view-transitions.surge.sh) and the [source on StackBlitz](https://stackblitz.com/edit/nuxt-view-transitions).

The Nuxt integration is under active development, but can be enabled with the `experimental.viewTransition` option in your configuration file:

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  experimental: {
    viewTransition: true
  }
})
```

The possible values are: `false`, `true`, or `'always'`.

If set to true, Nuxt will not apply transitions if the user's browser matches `prefers-reduced-motion: reduce` (recommended). If set to `always`, Nuxt will always apply the transition and it is up to you to respect the user's preference.

By default, view transitions are enabled for all [pages](/docs/4.x/guide/directory-structure/pages), but you can set a different global default.

```ts [nuxt.config.ts]twoslash
export default defineNuxtConfig({
  app: {
    // Disable view transitions globally, and opt-in on a per page basis
    viewTransition: false
  },
})
```

It is possible to override the default `viewTransition` value for a page by setting the `viewTransition` key in [`definePageMeta`](/docs/4.x/api/utils/define-page-meta) of the page:

```vue [pages/about.vue]twoslash
<script setup lang="ts">
definePageMeta({
  viewTransition: false
})
</script>
```

<warning>

Overriding view transitions on a per-page basis will only have an effect if you have enabled the `experimental.viewTransition` option.

</warning>

If you are also using Vue transitions like `pageTransition` and `layoutTransition` (see above) to achieve the same result as the new View Transitions API, then you may wish to *disable* Vue transitions if the user's browser supports the newer, native web API. You can do this by creating `~/middleware/disable-vue-transitions.global.ts` with the following contents:

```ts
export default defineNuxtRouteMiddleware(to => {
  if (import.meta.server || !document.startViewTransition) { return }

  // Disable built-in Vue transitions
  to.meta.pageTransition = false
  to.meta.layoutTransition = false
})
```

### Known Issues

- If you perform data fetching within your page setup functions, you may wish to reconsider using this feature for the moment. (By design, View Transitions completely freeze DOM updates whilst they are taking place.) We're looking at restricting the View Transition to the final moments before `<Suspense>` resolves, but in the interim you may want to consider carefully whether to adopt this feature if this describes you.



# Prose Components

> A list of Prose components.

Prose components are replacements for HTML typography tags. Prose components provide a simple way to customize content UI.

To overwrite a prose component, create a component with the same name in your project `components/content/` directory (ex: `components/content/ProseA.vue`).

<note>

Prose components are originally part of [`@nuxtjs/mdc`](https://github.com/nuxt-modules/mdc).

</note>

## `ProseA`

<code-group>

```md [Code]
[Link](/docs/components/prose)
```

<code-preview label="Preview" icon="i-lucide-eye">

[Link](/docs/components/prose)

</code-preview>
</code-group>

## `ProseBlockquote`

<code-group>

```md [Code]
> Block quote
```

<code-preview label="Preview" icon="i-lucide-eye">

> Block quote

</code-preview>
</code-group>

## `ProsePre`

<code-group>

```md [Code]
```js [file.js]{2} meta-info=val
  export default () => {
    console.log('Code block')
  }
  ```
```

<code-preview label="Preview" icon="i-lucide-eye">

```js [file.js]
export default () => {
  console.log('Code block')
}
```

</code-preview>
</code-group>

Component properties will be:

```json
{
  code: "export default () => {\n    console.log('Code block')\n}"
  language: "js"
  filename: "file.js"
  highlights: [2]
  meta: "meta-info=val"
}
```

Check out the [highlight options](/docs/getting-started/configuration#highlight) for more about the syntax highlighting.

<callout type="warning">

If you want to use `]` in the filename, you need to escape it with 2 backslashes: `\\]`. This is necessary since JS will automatically escape the backslash in a string so `\]` will be resolved as `]` breaking our regex.

</callout>

## `ProseCode`

<code-group>

```md [Code]
`code`

`const code: string = 'highlighted code inline'`{lang="ts"}
```

<code-preview label="Preview" icon="i-lucide-eye">

`code`

`const code: string = 'highlighted code inline'`

</code-preview>
</code-group>

## `ProseH1`

<code-group>

```md [Code]
# H1 Heading
```

<code-preview label="Preview" className="pt-4">

# H1 Heading

</code-preview>
</code-group>

## `ProseH2`

<code-group>

```md [Code]
## H2 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

## H2 Heading

</code-preview>
</code-group>

## `ProseH3`

<code-group>

```md [Code]
### H3 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

### H3 Heading

</code-preview>
</code-group>

## `ProseH4`

<code-group>

```md [Code]
#### H4 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

#### H4 Heading

</code-preview>
</code-group>

## `ProseH5`

<code-group>

```md [Code]
##### H5 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

##### H5 Heading

</code-preview>
</code-group>

## `ProseH6`

<code-group>

```md [Code]
###### H6 Heading
```

<code-preview label="Preview" icon="i-lucide-eye">

###### H6 Heading

</code-preview>
</code-group>

## `ProseHr`

<code-group>

```md [Code]
Divider under.

---

Divider above.
```

<code-preview label="Preview" icon="i-lucide-eye">

Divider under.

---

Divider above.

</code-preview>
</code-group>

## `ProseImg`

<code-group>

```md [Code]
![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)
```

<code-preview label="Preview" icon="i-lucide-eye">

![A Cool Image](https://nuxt.com/assets/design-kit/icon-green.png)

</code-preview>
</code-group>

## `ProseUl`

<code-group>

```md [Code]
- Just
- An
- Unordered
- List
```

<code-preview label="Preview" icon="i-lucide-eye">

- Just
- An
- Unordered
- List

</code-preview>
</code-group>

## `ProseLi`

<code-group>

```md [Code]
- List element
```

<code-preview label="Preview" icon="i-lucide-eye">

- List element

</code-preview>
</code-group>

## `ProseOl`

<code-group>

```md [Code]
1. Foo
2. Bar
3. Baz
```

<code-preview label="Preview" icon="i-lucide-eye">

1. Foo
2. Bar
3. Baz

</code-preview>
</code-group>

## `ProseP`

<code-group>

```md [Code]
Just a paragraph.
```

<code-preview label="Preview" icon="i-lucide-eye">

Just a paragraph.

</code-preview>
</code-group>

## `ProseStrong`

<code-group>

```md [Code]
**Just a strong paragraph.**
```

<code-preview label="Preview" icon="i-lucide-eye">

**Just a strong paragraph.**

</code-preview>
</code-group>

## `ProseEm`

<code-group>

```md [Code]
_Just an italic paragraph._
```

<code-preview label="Preview" icon="i-lucide-eye">

*Just an italic paragraph.*

</code-preview>
</code-group>

## `ProseTable`

<code-group>

```md [Code]
| Key | Type      | Description |
| --- | --------- | ----------- |
| 1   | Wonderful | Table       |
| 2   | Wonderful | Data        |
| 3   | Wonderful | Website     |
```

<code-preview label="Preview" icon="i-lucide-eye">
<table>
<thead>
  <tr>
    <th>
      Key
    </th>
    
    <th>
      Type
    </th>
    
    <th>
      Description
    </th>
  </tr>
</thead>

<tbody>
  <tr>
    <td>
      1
    </td>
    
    <td>
      Wonderful
    </td>
    
    <td>
      Table
    </td>
  </tr>
  
  <tr>
    <td>
      2
    </td>
    
    <td>
      Wonderful
    </td>
    
    <td>
      Data
    </td>
  </tr>
  
  <tr>
    <td>
      3
    </td>
    
    <td>
      Wonderful
    </td>
    
    <td>
      Website
    </td>
  </tr>
</tbody>
</table>
</code-preview>
</code-group>

## `ProseTbody`

Included in **ProseTable** example.

## `ProseTd`

Included in **ProseTable** example.

## `ProseTh`

Included in **ProseTable** example.

## `ProseThead`

Included in **ProseTable** example.

## `ProseTr`

Included in **ProseTable** example.

<callout icon="i-simple-icons-github" to="https://github.com/nuxt-modules/mdc/tree/main/src/runtime/components/prose">

Checkout the source code for these components on GitHub.

</callout>